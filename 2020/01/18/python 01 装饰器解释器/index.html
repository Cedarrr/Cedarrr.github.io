<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="Python 解释器,装饰器"><meta name="keywords" content="java, bioinformatics, python"><link rel="alternate" href="/Cedarrr.github.io/atom.xml" title="Cedar's blog"><link rel="shortcut icon" type="image/x-icon" href="/Cedarrr.github.io/icon2.png?v=2.11.0">
<link rel="canonical" href="https://cedarrr.github.io/Cedarrr.github.io/2020/01/18/python 01 装饰器解释器/">

<link rel="stylesheet" type="text/css" href="/Cedarrr.github.io/lib/fancybox/jquery.fancybox.css">
<link rel="stylesheet" type="text/css" href="/Cedarrr.github.io/css/style.css?v=2.11.0">

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>Python 解释器,装饰器 - Cedar's blog</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/Cedarrr.github.io/." class="logo">Cedar's blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/Cedarrr.github.io/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/Cedarrr.github.io/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/Cedarrr.github.io/." class="logo">Cedar's blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/Cedarrr.github.io/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/Cedarrr.github.io/tags/">
            Tags
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">Python 解释器,装饰器
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-01-18
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-基本知识"><span class="toc-text">1. 基本知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-解释器"><span class="toc-text">1.1 解释器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-用户输入"><span class="toc-text">1.2 用户输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-pycharm"><span class="toc-text">1.3 pycharm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-用户输入"><span class="toc-text">1.4 用户输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-模块初识"><span class="toc-text">1.5 模块初识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-pyc文件"><span class="toc-text">1.6 pyc文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-基础的代码"><span class="toc-text">1.7 基础的代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-内置参数"><span class="toc-text">1.8 内置参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-软件目录结构规范"><span class="toc-text">1.9 软件目录结构规范</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2"><span class="toc-text">2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-装饰器-decorator"><span class="toc-text">2.1 装饰器 decorator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-生成器-generator"><span class="toc-text">2.2 生成器 generator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-迭代器-Iterator"><span class="toc-text">2.3 迭代器 Iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-Json-amp-pickle数据序列化"><span class="toc-text">2.4 Json &amp; pickle数据序列化</span></a></li></ol></li></ol>
    </div>
  </div><div class="post-content"><h1 id="1-基本知识"><a href="#1-基本知识" class="headerlink" title="1. 基本知识"></a>1. 基本知识</h1><h2 id="1-1-解释器"><a href="#1-1-解释器" class="headerlink" title="1.1 解释器"></a>1.1 解释器</h2><p>python解释器在加载.py文件中的代码时，会对内容进行编码（默认ascill)，所以需要在代码中加入使用utf-8解释器的代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*- </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">print</span>` `<span class="string">"你好，世界"</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="1-2-用户输入"><a href="#1-2-用户输入" class="headerlink" title="1.2 用户输入"></a>1.2 用户输入</h2><p>注意在python2.x中尽量使用raw_input因为它会自动把用户的输入的东西存为str的格式，相当于python3当中的input。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#raw_input仅仅只在python2.x里面有用</span></span><br><span class="line">name = raw_input(<span class="string">"What is your name?"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="1-3-pycharm"><a href="#1-3-pycharm" class="headerlink" title="1.3 pycharm"></a>1.3 pycharm</h2><p>设置每次创建新py文件的模板<br><code>view-&gt;appearance-&gt;toolbar</code>，点击出现菜单里面的扳手符号。<code>editor-&gt;file and code templates</code></p>
<h2 id="1-4-用户输入"><a href="#1-4-用户输入" class="headerlink" title="1.4 用户输入"></a>1.4 用户输入</h2><p>这个代码不能在pycharm环境下使用，但在cmd中是可以的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python </span></span><br><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="keyword">import</span> getpass</span><br><span class="line"></span><br><span class="line">name = raw_input(<span class="string">"What is your name?"</span>)</span><br><span class="line">pwd=getpass.getpass(<span class="string">"password:"</span>)</span><br><span class="line">print(<span class="string">"Hello "</span> + name )</span><br><span class="line">print(pwd)</span><br></pre></td></tr></table></figure>

<h2 id="1-5-模块初识"><a href="#1-5-模块初识" class="headerlink" title="1.5 模块初识"></a>1.5 模块初识</h2><ul>
<li>创建的文件名不可以与导入的库名相同，例如创建的文件叫<code>sys</code>那么在<code>import sys</code>的时候，会先在当前目录下寻找，就找到了自己创建的文件。在python2.x里会报错，但python3.x好像已经修复了这个问题。但尽量还是不要使用。</li>
</ul>
<p>sys模块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印环境变量</span></span><br><span class="line">print(sys.path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在pycharm中打印绝对路径</span></span><br><span class="line"><span class="comment"># 如果是在cmd下面，打印文件名并以列表中的一项这种形式出现</span></span><br><span class="line"><span class="comment"># python sys_mod.py 1 2 3</span></span><br><span class="line"><span class="comment"># 结果会出现['sys_mod.py','1','2','3']</span></span><br><span class="line"><span class="comment"># print(sys.argv[2])则会取出2这个字符</span></span><br><span class="line">print(sys.argv)</span><br></pre></td></tr></table></figure>

<p>os模块： 实现与系统的交互</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实现与系统的交互</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">"dir"</span>) <span class="comment"># os.system 执行命令，不保存结果</span></span><br><span class="line">os.popen(<span class="string">"dir"</span>) <span class="comment"># os.popen执行命令，并把结果存在一个地址，会返回地址</span></span><br></pre></td></tr></table></figure>

<h2 id="1-6-pyc文件"><a href="#1-6-pyc文件" class="headerlink" title="1.6 pyc文件"></a>1.6 pyc文件</h2><p><code>lib/_pycache_</code>文件夹中会存放pyc文件</p>
<p><strong>编译型语言</strong>：C语言。就是在程序执行之前，会先同各国编译器对程序执行一个编译的过程，把程序转变为机器语言，运行时就不需要编译，速度更快。<br><strong>解释型语言</strong>：Python, Ruby。没有编译的过程，而是在程序运行的时候，通过解释器对程序逐行做出解释，然后直接运行。</p>
<p>随着Java等基于虚拟机的语言的兴起，语言不可以再被直接分为解释型和编译型这两种。以Java为例，Java首先是通过编译器编译成字节码文件，然后在运行时通过解释器给解释成机器文件，所以说Java是一种先编译后解释的语言。</p>
<p>在命令行中输入<code>python hello.py</code>的时候，其实是激活了Python的解释器告诉解释器要开始工作了。可是在“解释之前”执行的第一项工作其实和java是一样的，就是编译。</p>
<p><strong>python的运行过程</strong><br>当python程序运行的时候，编译的结果是保存在位于内存中的PyCodeObject中，当python程序运行结束时，python解释器九江PyCodeObject写回到pyc文件中。<br>当Python二次运行的时候，程序会先在硬盘中寻找pyc文件，如果找到，就直接写入否则就重复上面的过程。在找到pyc文件的同时，还会比较代码和pyc文件的更新时间，如果不一致还是会重复上述过程<strong>所以pyc文件其实似乎PyCodeObject的一种持久化保存方式。</strong></p>
<h2 id="1-7-基础的代码"><a href="#1-7-基础的代码" class="headerlink" title="1.7 基础的代码"></a>1.7 基础的代码</h2><ol>
<li><p>列表的复制要用<code>list_name.copy()</code>而不要直接<code>new_list=old_list</code>。</p>
</li>
<li><p>字典的多级目录</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data=&#123;</span><br><span class="line">    <span class="string">'new york'</span>:&#123;</span><br><span class="line">        <span class="string">'university'</span>:&#123;</span><br><span class="line">            <span class="string">'fashion'</span>:[<span class="string">"left"</span>,<span class="string">"right"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'uk'</span>:&#123;</span><br><span class="line">        <span class="string">"london"</span>:[<span class="string">"kings cross station"</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(data[<span class="string">'new york'</span>][<span class="string">"university"</span>][<span class="string">"boston"</span>][<span class="number">0</span>])  <span class="comment">## 打印结果是left</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数</p>
</li>
</ol>
<ul>
<li><strong>匿名函数</strong> ：就是不需要显式的指定函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(n)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> n**n</span><br><span class="line">print(calc(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匿名函数</span></span><br><span class="line">calc=<span class="keyword">lambda</span> n::n**n</span><br><span class="line">print(calc(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匿名函数一般会搭配其他的函数使用</span></span><br><span class="line">res=map(<span class="keyword">lambda</span> x:x**<span class="number">2</span>,[<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">8</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">	print(i)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>递归函数</strong>： 在函数内部调用自己的函数</p>
<ul>
<li>递归必须有一个明确的结束条件</li>
<li>每次进入更深一层递归时，问题规模比上次递归都应有所减少</li>
<li>递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出）</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(n)</span><br><span class="line">    <span class="keyword">if</span> int(n/<span class="number">2</span>)&gt;<span class="number">0</span>:    <span class="comment"># 这里必须要加int， 要不出现小数就永元不会达到这个条件</span></span><br><span class="line">        <span class="keyword">return</span> calc(n/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">calc(<span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<p>递归应用于二分查找法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(dataset, find_num)</span>:</span></span><br><span class="line">    print(dataset)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(dataset) &gt; <span class="number">1</span>:</span><br><span class="line">        mid = int(len(dataset) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> dataset[mid] == find_num:  <span class="comment"># find it</span></span><br><span class="line">            print(<span class="string">"找到数字"</span>, dataset[mid])</span><br><span class="line">        <span class="keyword">elif</span> dataset[mid] &gt; find_num:  <span class="comment"># 找的数在mid左面</span></span><br><span class="line">            print(<span class="string">"\033[31;1m找的数在mid[%s]左面\033[0m"</span> % dataset[mid])</span><br><span class="line">            <span class="keyword">return</span> binary_search(dataset[<span class="number">0</span>:mid], find_num)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 找的数在mid右面</span></span><br><span class="line">            print(<span class="string">"\033[32;1m找的数在mid[%s]右面\033[0m"</span> % dataset[mid])</span><br><span class="line">            <span class="keyword">return</span> binary_search(dataset[mid + <span class="number">1</span>:], find_num)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> dataset[<span class="number">0</span>] == find_num:  <span class="comment"># find it</span></span><br><span class="line">            print(<span class="string">"找到数字啦"</span>, dataset[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"没的分了,要找的数字[%s]不在列表里"</span> % find_num)</span><br><span class="line"></span><br><span class="line">data = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">30</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">35</span>]</span><br><span class="line">binary_search(data, <span class="number">66</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>高阶函数</strong>：一个函数可以接收另一个函数作为参数，这种函数就称之为高阶函数。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x,y,f)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> f(x)+f(y)</span><br><span class="line"></span><br><span class="line">res=add(<span class="number">3</span>,<span class="number">-6</span>,abs)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="1-8-内置参数"><a href="#1-8-内置参数" class="headerlink" title="1.8 内置参数"></a>1.8 内置参数</h2><p><code>all(iterablei)</code>:如果可迭代对象里面，所有对象都为真，结果就是真。（数字里非0即为真）<br><code>any(iterablei)</code>:如果可迭代对象里面，有真即为真。</p>
<h2 id="1-9-软件目录结构规范"><a href="#1-9-软件目录结构规范" class="headerlink" title="1.9 软件目录结构规范"></a>1.9 软件目录结构规范</h2><p>设计一个层次清晰的目录结构，就是为了达到一下两点：</p>
<ul>
<li>可读性高：不熟悉这个项目代码的人，一眼就能看懂目录结构，直到程序启动脚本是哪个，测试目录在哪里，配置文件在哪里等，从而非常快速的了解这个项目。</li>
<li>可维护性高：定义好组织规则后，维护者就能很明确地直到，新增地哪个文件和代码应该放在什么目录之下。这个好处是，随着时间的推移，代码/配置的规模增加，项目结构不会混乱，依然能组织好。</li>
</ul>
<p>假设你的项目名为foo, 我比较建议的最方便快捷目录结构这样就足够了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Foo/</span><br><span class="line">|-- bin/</span><br><span class="line">|   |-- foo</span><br><span class="line">|</span><br><span class="line">|-- foo/</span><br><span class="line">|   |-- tests/</span><br><span class="line">|   |   |-- __init__.py</span><br><span class="line">|   |   |-- test_main.py</span><br><span class="line">|   |</span><br><span class="line">|   |-- __init__.py</span><br><span class="line">|   |-- main.py</span><br><span class="line">|</span><br><span class="line">|-- docs/</span><br><span class="line">|   |-- conf.py</span><br><span class="line">|   |-- abc.rst</span><br><span class="line">|</span><br><span class="line">|-- setup.py</span><br><span class="line">|-- requirements.txt</span><br><span class="line">|-- README</span><br></pre></td></tr></table></figure>

<p>简要解释一下:</p>
<ul>
<li>bin/: 存放项目的一些可执行文件，当然你可以起名script/之类的也行。</li>
<li>foo/: 存放项目的所有源代码。(1) 源代码中的所有模块、包都应该放在此目录。不要置于顶层目录。(2) 其子目录tests/存放单元测试代码； (3) 程序的入口最好命名为main.py。</li>
<li>docs/: 存放一些文档。</li>
<li>setup.py: 安装、部署、打包的脚本。</li>
<li>requirements.txt: 存放软件依赖的外部Python包列表。</li>
<li>README: 项目说明文件。</li>
<li>除此之外，有一些方案给出了更加多的内容。比如LICENSE.txt,ChangeLog.txt文件等，我没有列在这里，因为这些东西主要是项目开源的时候需要用到。如果你想写一个开源软件，目录该如何组织，可以参考<a href="https://www.jeffknupp.com/blog/2013/08/16/open-sourcing-a-python-project-the-right-way/" title="这篇文章" target="_blank" rel="noopener">这篇文章</a>。</li>
</ul>
<p>下面，再简单讲一下我对这些目录的理解和个人要求吧。</p>
<ol>
<li><p>关于<strong>README</strong>的内容</p>
<p>这个我觉得是每个项目都应该有的一个文件，目的是能简要描述该项目的信息，让读者快速了解这个项目。</p>
</li>
</ol>
<p>它需要说明以下几个事项：</p>
<ul>
<li>软件定位，软件的基本功能。</li>
<li>运行代码的方法: 安装环境、启动命令等。</li>
<li>简要的使用说明。</li>
<li>代码目录结构说明，更详细点可以说明软件的基本原理。</li>
</ul>
<p>常见问题说明。<br>  我觉得有以上几点是比较好的一个README。在软件开发初期，由于开发过程中以上内容可能不明确或者发生变化，并不是一定要在一开始就将所有信息都补全。但是在项目完结的时候，是需要撰写这样的一个文档的。<br>  可以参考Redis源码中Readme的写法，这里面简洁但是清晰的描述了Redis功能和源码结构。</p>
<ol start="2">
<li>关于<strong>requirements.txt和setup.py</strong></li>
</ol>
<p><strong>setup.py</strong><br>一般来说，用setup.py来管理代码的打包、安装、部署问题。业界标准的写法是用Python流行的打包工具<strong>setuptools</strong>来管理这些事情。这种方式普遍应用于开源项目中。不过这里的核心思想不是用标准化的工具来解决这些问题，而是说，一个项目一定要有一个安装部署工具，能快速便捷的在一台新机器上将环境装好、代码部署好和将程序运行起来。</p>
<p>  我刚开始接触Python写项目的时候，安装环境、部署代码、运行程序这个过程全是手动完成，遇到过以下问题:</p>
<ul>
<li>安装环境时经常忘了最近又添加了一个新的Python包，结果一到线上运行，程序就出错了。</li>
<li>Python包的版本依赖问题，有时候我们程序中使用的是一个版本的Python包，但是官方的已经是最新的包了，通过手动安装就可能装错了。</li>
<li>如果依赖的包很多的话，一个一个安装这些依赖是很费时的事情。</li>
<li>新同学开始写项目的时候，将程序跑起来非常麻烦，因为可能经常忘了要怎么安装各种依赖。</li>
<li>setup.py可以将这些事情自动化起来，提高效率、减少出错的概率。”复杂的东西自动化，能自动化的东西一定要自动化。”是一个非常好的习惯。</li>
<li>setuptools的文档比较庞大，刚接触的话，可能不太好找到切入点。学习技术的方式就是看他人是怎么用的，可以参考一下Python的一个Web框架，flask是如何写的: setup.py</li>
<li>当然，简单点自己写个安装脚本（deploy.sh）替代setup.py也未尝不可。</li>
</ul>
<p><strong>requirements.txt</strong><br>这个文件存在的目的是:</p>
<ul>
<li>方便开发者维护软件的包依赖。将开发过程中新增的包添加进这个列表中，避免在setup.py安装依赖时漏掉软件包。</li>
<li>方便读者明确项目使用了哪些Python包。</li>
<li>这个文件的格式是每一行包含一个包依赖的说明，通常是flask&gt;=0.10这种格式，要求是这个格式能被pip识别，这样就可以简单的通过 pip install -r requirements.txt来把所有Python包依赖都装好了。具体格式说明： <a href="https://pip.readthedocs.io/en/1.1/requirements.html" title="点这里" target="_blank" rel="noopener">点这里</a>。</li>
</ul>
<ol start="3">
<li><strong>关于配置文件的使用方法</strong><br>注意，在上面的目录结构中，没有将conf.py放在源码目录下，而是放在<strong>docs/</strong>目录下。<br>很多项目对配置文件的使用做法是:</li>
</ol>
<ul>
<li>配置文件写在一个或多个python文件中，比如此处的conf.py。</li>
<li>项目中哪个模块用到这个配置文件就直接通过import conf这种形式来在代码中使用配置。</li>
</ul>
<p>这种做法我不太赞同:</p>
<ul>
<li>这让单元测试变得困难（因为模块内部依赖了外部配置）</li>
<li>另一方面配置文件作为用户控制程序的接口，应当可以由用户自由指定该文件的路径。</li>
<li>程序组件可复用性太差，因为这种贯穿所有模块的代码硬编码方式，使得大部分模块都依赖conf.py这个文件。</li>
</ul>
<p>所以，我认为配置的使用，更好的方式是，</p>
<ul>
<li>模块的配置都是可以灵活配置的，不受外部配置文件的影响。</li>
<li>程序的配置也是可以灵活控制的。<br>能够佐证这个思想的是，用过nginx和mysql的同学都知道，nginx、mysql这些程序都可以自由的指定用户配置。<br>所以，不应当在代码中直接import conf来使用配置文件。上面目录结构中的conf.py，是给出的一个配置样例，不是在写死在程序中直接引用的配置文件。可以通过给main.py启动参数指定配置路径的方式来让程序读取配置内容。当然，这里的conf.py你可以换个类似的名字，比如settings.py。或者你也可以使用其他格式的内容来编写配置文件，比如settings.yaml之类的。</li>
</ul>
<p>bin/atm.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前文件路径，以获得其他文件夹下想要引用文件的路径</span></span><br><span class="line"><span class="comment"># 返回当前文件的相对路径，在pycharm里面显示为绝对路径，但实际为相对</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># os.path.dirname 仅要路径名，不要文件名</span></span><br><span class="line"><span class="comment"># os.path.abspath 根据相对路径，获得绝对路径</span></span><br><span class="line"></span><br><span class="line">BASE_DIR=os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加环境变量</span></span><br><span class="line">sys.path.append(BASE_DIR)</span><br><span class="line"><span class="keyword">import</span> conf,core</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> core <span class="keyword">import</span> main</span><br><span class="line"></span><br><span class="line">main.login()</span><br></pre></td></tr></table></figure>

<p>core/main.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一般不在main里面写主逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Welcome to my atm"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><h2 id="2-1-装饰器-decorator"><a href="#2-1-装饰器-decorator" class="headerlink" title="2.1 装饰器 decorator"></a>2.1 装饰器 decorator</h2><p><strong>装饰器：</strong></p>
<p><strong>定义</strong>：本质是函数，关键语法都是用def定义的。是用来装饰其他函数，为其他函数添加附加功能。<br><strong>原则</strong>：1. 不能修改被装饰的函数的源代码。2. 不能修改被装饰的函数的调用方式。也就是装饰器对被修改的函数是完全透明的。</p>
<p><strong>实现装饰器的知识储备</strong>：高阶函数+嵌套函数-》装饰器</p>
<ol>
<li>函数即“变量”</li>
<li>高阶函数</li>
<li>嵌套函数</li>
</ol>
<ol>
<li><p>函数即变量<br>函数就像变量一样，当创建函数的时候，就在内存中划分一个空间装函数体，函数名就相当于变量名是个门牌号。<br>python中的内存回收机制是当没有门牌号的时候，里面的值就会被清空。匿名函数没有函数名，所以立刻会被回收。但如果匿名函数赋给给某个值，就相当于给予了门牌号。</p>
</li>
<li><p>高阶函数</p>
<ul>
<li>把一个函数名当作实参传给另外一个函数 （在步修改被装饰函数源代码的情况下为其添加功能）</li>
<li>返回值中包含函数名</li>
</ul>
</li>
</ol>
<p>理解装饰器的作用方法.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"in the bar"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(func)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line">    </span><br><span class="line"><span class="comment">#print(test1(bar)) # 注意这里要传bar而非bar(),因为bar是门牌号</span></span><br><span class="line">				   <span class="comment"># 而bar()是bar这个函数的运行结果，如果传bar()</span></span><br><span class="line">				   <span class="comment"># 那么传给test1的就不是函数了</span></span><br><span class="line">bar=test1(bar) <span class="comment">#这里就相当于改写了门牌号bar指向的地址</span></span><br><span class="line">bar()</span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="comment">#&lt;function bar at 0x02BFE7C0&gt;</span></span><br><span class="line"><span class="comment">#&lt;function bar at 0x02BFE7C0&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>嵌套函数<br>函数的嵌套是在一个函数内容，def一个新的函数，而不只是单纯的调用某个函数。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"in the foo"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span>    <span class="comment"># 这个函数具有局部变量的特性，不能在外部被调用。</span></span><br><span class="line">        print(<span class="string">"in the bar"</span>)</span><br><span class="line">    bar()</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>当没有参数的时候，装饰器的使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span> <span class="comment">#timer(test1)    func=test1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">timer2</span><span class="params">()</span>:</span></span><br><span class="line">        start_time=time.time()</span><br><span class="line">        func() <span class="comment"># run test1()</span></span><br><span class="line">        end_time=time.time()</span><br><span class="line">        print(<span class="string">"the func run time is %s"</span>%(end_time-start_time))</span><br><span class="line">    <span class="keyword">return</span> timer2 <span class="comment"># 返回地址</span></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"in the test1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把地址赋给这个原来的门牌号</span></span><br><span class="line"><span class="comment"># @timer写在上面就相当于这一步</span></span><br><span class="line"><span class="comment"># test1=timer(test1)</span></span><br><span class="line"></span><br><span class="line">test1() <span class="comment"># 这里实际上是在执行timer2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"><span class="comment">#in the test1</span></span><br><span class="line"><span class="comment">#the func run time is 3.0004637241363525</span></span><br></pre></td></tr></table></figure>

<p>非固定参数，装饰器。<code>*args, **kwargs</code>是非固定参数，此时，不管被修饰的函数有几个参数，都可以使用了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span> <span class="comment">#timer(test1)    func=test1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">timer2</span><span class="params">(*args,**kwargs)</span>:</span> <span class="comment"># *args, **kwargs是非固定参数</span></span><br><span class="line">        start_time=time.time()</span><br><span class="line">        func(*args,**kwargs) <span class="comment"># run test1()</span></span><br><span class="line">        end_time=time.time()</span><br><span class="line">        print(<span class="string">"the func run time is %s"</span>%(end_time-start_time))</span><br><span class="line">    <span class="keyword">return</span> timer2 <span class="comment"># 返回地址</span></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"in the test1"</span>)</span><br><span class="line"><span class="meta">@timer  # test2=timer(test2)=timer2     test2(name)=timer2(name)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"test2"</span>,name)</span><br></pre></td></tr></table></figure>

<p>进阶版，根据不同的页面，用不同的方式进行验证</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">user,passwd=<span class="string">"alex"</span>,<span class="string">"abc123"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">auth</span><span class="params">(auth_type)</span>:</span></span><br><span class="line">    <span class="comment">#print("auth func",auth_type)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">outer_wrapper</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="comment">#print("auth func args",*args, **kwargs)</span></span><br><span class="line"></span><br><span class="line">            username = input(<span class="string">"Username:"</span>).strip()</span><br><span class="line">            password = input(<span class="string">"Password:"</span>).strip()</span><br><span class="line">            <span class="keyword">if</span> auth_type == <span class="string">"local"</span>:</span><br><span class="line">                <span class="keyword">if</span> user == username <span class="keyword">and</span> passwd == password:</span><br><span class="line">                    print(<span class="string">"\033[32:1mUser has passed authentication\033[Om"</span>)  <span class="comment"># 以绿色的颜色打印一句登陆成功的提示语</span></span><br><span class="line">                    res = func(*args, **kwargs)  <span class="comment"># 这就就相当于func在执行，但由于这个值没有传递给任何变量，所以如果原func是有返回值的</span></span><br><span class="line">                    <span class="comment"># 在这里就会丢失，所以需要在这里把res赋值</span></span><br><span class="line">                    print(<span class="string">"---after authentication"</span>)</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    exit(<span class="string">"\033[31:1mInvalid username or passwd\033[Om"</span>)  <span class="comment"># 以红色的颜色打印一句登陆成功的提示语</span></span><br><span class="line">            <span class="keyword">elif</span> auth_type==<span class="string">"ldap"</span>:</span><br><span class="line">                print(<span class="string">"get ldap"</span>)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> outer_wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Welcome to index page"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@auth(auth_type="local")  #希望实现home页面用本地的文件验证</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"welcome to home page"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"from home"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@auth(auth_type="ldap")  # bbs用ldap的方法验证</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bbs</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"welcome to bbs page"</span>)</span><br><span class="line"></span><br><span class="line">index()</span><br><span class="line">print(home()) <span class="comment"># 在这里调用hone，相当于调用wrapper</span></span><br><span class="line">bbs()</span><br></pre></td></tr></table></figure>

<h2 id="2-2-生成器-generator"><a href="#2-2-生成器-generator" class="headerlink" title="2.2 生成器 generator"></a>2.2 生成器 generator</h2><p>2.3.1 列表生成式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[i*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#还可以加入函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[func(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure>

<p>2.3.2 生成器</p>
<p>生成器：</p>
<ul>
<li>只有在调用时才会生成象映的数据</li>
<li>只记录当前位置</li>
<li>只有一个<code>__next__()</code>方法（此方法用于python3.x，python2.x用<code>next()</code></li>
</ul>
<p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅只访问前面几个元素，后面的空间就被白白浪费了。所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环过程中不断推算出后续的元素呢？这样就不必创建完整的list， <strong>从而节省大量的空间</strong>。在python中，这样<strong>一边循环一边计算的机器，称为生成器generator</strong>。</p>
<p>要创建一个generator, </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=(i*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x01605808</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=((i*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> b: print(i)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>生成器不支持直接根据index，调取相关序列的值，如<code>b[2]</code>，不可以用切片下标等方式来取值。生成器用for循环这种方式一个一个取，才可以取出来。生成器节省空间的方式就是只记住当前位置。可以利用<code>b.__next__()</code>这种方式，调用当前位置的下一个，且不能返回到前一个。</p>
<p>generator非常强大，如果推算的算法比较复杂。用类似列表生成式的for循环无法实现的时候，还可以用函数来实现，例如斐波那契数列（Fibonacci）。<code>yield</code>相当于<code>return</code>会返回值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max1)</span>:</span></span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; max1:</span><br><span class="line">        <span class="comment">#print(b)</span></span><br><span class="line">        <span class="keyword">yield</span> b   <span class="comment">#注意这里要用yield。此时这段代码就是generator而非函数。</span></span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'--done--'</span> <span class="comment"># 错误的时候，返回的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> fib(<span class="number">3</span>):</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">f=fib(<span class="number">3</span>)</span><br><span class="line">print(f.__next__()) <span class="comment">#这里用__next__()取下面的值</span></span><br><span class="line">print(<span class="string">"==========="</span>) <span class="comment">#生成器可以随时停止，这有利于在单线程的情况下实现多线程。</span></span><br><span class="line">print(f.__next__())</span><br><span class="line">print(f.__next__())</span><br><span class="line">print(f.__next__()) <span class="comment">#这里取值，超过了范围，就会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="comment">#===========</span></span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="comment">#2</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File "D:/school/mooc/untitled1/day2/generator1.py", line 14, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#     print(f.__next__())</span></span><br><span class="line"><span class="comment"># StopIteration: --done--</span></span><br></pre></td></tr></table></figure>

<p>利用<code>try except</code>来捕获错误。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">f=fib(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x=next(f)</span><br><span class="line">        print(<span class="string">'g:'</span>,x)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"Generator return value:"</span>,e.value)</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>还可以利用生成器在单线程的情况下可以实现多线程的效果（即协程），这里的代码就是异步IO的雏形。<code>xx.send()</code>的作用是<code>resumes the generator and &quot;sends&quot; a value that becomes the result of the current yield-expression</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"%s 准备吃包子啦！"</span> %name)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        baozi=<span class="keyword">yield</span></span><br><span class="line">        print(<span class="string">"包子[%s]来了，被[%s]吃了"</span> %(baozi,name))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(name)</span>:</span></span><br><span class="line">    c=consumer(<span class="string">'A'</span>)</span><br><span class="line">    c2=consumer(<span class="string">'B'</span>)</span><br><span class="line">    c.__next__() <span class="comment">#要先next一下，走到第一次返回的地方，为了打印“准备吃包子”这句话</span></span><br><span class="line">    c2.__next__()</span><br><span class="line">    print(<span class="string">"要开始做包子啦！"</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">"做了两个包子！"</span>)</span><br><span class="line">        c.send(i)  <span class="comment">#把 i的值传入，被yield接收</span></span><br><span class="line">        c2.send(i)</span><br><span class="line"></span><br><span class="line">producer(<span class="string">"alex"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-3-迭代器-Iterator"><a href="#2-3-迭代器-Iterator" class="headerlink" title="2.3 迭代器 Iterator"></a>2.3 迭代器 Iterator</h2><p>一般可以直接用于for循环的数据类型有一下两种：</p>
<ul>
<li>集合数据类型，如list, tuple, dict, set, str等</li>
<li>generator,包括生成器和带yield的generator function<br>这些可以直接作用于for循环的对象可以统称为<strong>可迭代对象：Iterable</strong>。可以使用<code>isinstance()</code>来判断一个对象是否是<strong>Iterable对象</strong>。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">"123"</span>,Iterable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">123</span>,Iterable)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>而生成器不但可以作用于for循环，还可以被next()函数不断调用病返回下一个值，知道最后抛出<code>StopIteration</code>错误表示无法继续返回下一个值了。</p>
<p><strong>可以被next()函数调用并不断返回下一个值得对象称为迭代器：Iterator</strong></p>
<p>生成器都是Iterator 对象，但list, dict， str虽然是Iterable, 但却不是Iterator。因为python的Iterator对象表示的是一个数据流。Iterator对象可以被<strong>next</strong>()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看成是一个有序序列，但我们却不能提前直到序列的长度，只能不断通过<code>next()</code>函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p>
<p>把list, dict, str等iterable变成iterator可以使用<code>iter()</code>函数。</p>
<p>Iterator甚至可以表示一个无限大的数据流，例如全体自然数，而使用list是永远不可能存储全体自然数的。</p>
<h2 id="2-4-Json-amp-pickle数据序列化"><a href="#2-4-Json-amp-pickle数据序列化" class="headerlink" title="2.4 Json &amp; pickle数据序列化"></a>2.4 Json &amp; pickle数据序列化</h2><p>2.4.1 Json</p>
<p>Json正在成为主流的<strong>不同平台之间简单数据</strong>的交换工具。之前的xml主要的作用也是不同的语言之间进行数据交互，现在正在被json取代。<strong>一个文件只能dump一次，也只能Load一次</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不标准做法，应尽量避免</span></span><br><span class="line"><span class="comment"># 写入文件</span></span><br><span class="line">info=&#123;</span><br><span class="line">    <span class="string">'name'</span>:<span class="string">'alex'</span>,</span><br><span class="line">    <span class="string">'age'</span>:<span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line">f=open(<span class="string">"test.test"</span>,<span class="string">"w"</span>)</span><br><span class="line">f.write(str(info))</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到已变成字符串的字典中的数据值</span></span><br><span class="line">f=open(<span class="string">"test.test"</span>,<span class="string">"r"</span>)</span><br><span class="line">data=eval(f.read()) <span class="comment">#eval能返回传入字符串的表达式的结果。</span></span><br><span class="line">f.close()</span><br><span class="line">print(data[<span class="string">'age'</span>])</span><br></pre></td></tr></table></figure>

<p>引入<code>Json</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#json序列化</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">info=&#123;</span><br><span class="line">    <span class="string">'name'</span>:<span class="string">'alex'</span>,</span><br><span class="line">    <span class="string">'age'</span>:<span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line">f=open(<span class="string">"test.txt"</span>,<span class="string">"w"</span>)</span><br><span class="line">f.write(json.dumps(info))</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#json返序列化</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">f = open(<span class="string">"test.txt"</span>,<span class="string">"r"</span>)</span><br><span class="line">data = json.loads(f.read())</span><br><span class="line">print(data[<span class="string">"age"</span>])</span><br></pre></td></tr></table></figure>

<p>2.4.2 Pickle</p>
<p>pickle与json的用法几乎完全一致。但pickel可以序列化函数等更复杂的数据类型。java只认识json，不认识pickle。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pickle序列化</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"hello"</span>,name)</span><br><span class="line">info=&#123;</span><br><span class="line">    <span class="string">'name'</span>:<span class="string">'alex'</span>,</span><br><span class="line">    <span class="string">'age'</span>:<span class="number">22</span>,</span><br><span class="line">    <span class="string">"func"</span>:sayhi</span><br><span class="line">&#125;</span><br><span class="line">f=open(<span class="string">"test.txt"</span>,<span class="string">"wb"</span>) <span class="comment">#以二进制的形式读入文件，pickle要求</span></span><br><span class="line"><span class="comment"># f.write(pickle.dumps(info)) #与下面的一致</span></span><br><span class="line">pickle.dump(info,f) </span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#pickle返序列化</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="comment">#这里只需要函数名一样，里面的内容不一样都可以</span></span><br><span class="line"><span class="comment">#pickle序列化的是整个对象，而非仅仅只是个内存地址</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"hello"</span>,name)</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">"test.txt"</span>,<span class="string">"rb"</span>) <span class="comment">#以二进制的形式读入</span></span><br><span class="line"><span class="comment">#data = pickle.loads(f.read())与下面一致</span></span><br><span class="line">data = pickle.load(f)</span><br><span class="line">print(data[<span class="string">"func"</span>](<span class="string">"alex"</span>))</span><br></pre></td></tr></table></figure>

<p><strong>Reference:</strong></p>
<ol>
<li>课程网页：<a href="https://www.cnblogs.com/alex3714/articles/5465198.html" target="_blank" rel="noopener">https://www.cnblogs.com/alex3714/articles/5465198.html</a></li>
<li>装饰器，迭代器和生成器：<a href="https://www.cnblogs.com/alex3714/articles/5765046.html" target="_blank" rel="noopener">https://www.cnblogs.com/alex3714/articles/5765046.html</a></li>
<li>内置函数：<a href="https://www.runoob.com/python/python-built-in-functions.html" target="_blank" rel="noopener">https://www.runoob.com/python/python-built-in-functions.html</a></li>
<li>python中eval的强大与危害：<a href="https://blog.csdn.net/liuchunming033/article/details/87643041" target="_blank" rel="noopener">https://blog.csdn.net/liuchunming033/article/details/87643041</a></li>
</ol>

      </div>
      
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/Cedarrr.github.io/tags/python/">python</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/Cedarrr.github.io/2020/02/08/javascript-学习笔记/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">javascript 学习笔记</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/Cedarrr.github.io/2020/01/12/NGS-Reading/">
        <span class="next-text nav-default">NGS Reading</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:mesliu97@gmail.com" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/Cedarrr" class="iconfont icon-github" title="github"></a>
        </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2019 - 2020<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Cedar</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/Cedarrr.github.io/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/Cedarrr.github.io/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/Cedarrr.github.io/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/Cedarrr.github.io/js/src/even.js?v=2.11.0"></script>
</body>
</html>
