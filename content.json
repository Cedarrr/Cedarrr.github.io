{"meta":{"title":"Cedar's blog","subtitle":"学习笔记","description":null,"author":"Cedar","url":"https://cedarrr.github.io/Cedarrr.github.io","root":"/Cedarrr.github.io/"},"pages":[{"title":"tags","date":"2020-01-11T17:41:31.000Z","updated":"2020-01-11T17:42:14.163Z","comments":true,"path":"tags/index.html","permalink":"https://cedarrr.github.io/Cedarrr.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"python 03 网络编程","slug":"python-03-网络编程","date":"2020-02-16T14:35:00.000Z","updated":"2020-02-16T14:45:35.176Z","comments":true,"path":"2020/02/16/python-03-网络编程/","link":"","permalink":"https://cedarrr.github.io/Cedarrr.github.io/2020/02/16/python-03-网络编程/","excerpt":"1. 基本概念1.1 网络通信概述主要分为udp和tcp， udp比较简单，tcp比较难 ** 网络**就是一种辅助双方或者多方能够连接在一起的工具 使用网络的目的：数据交换就是为了联通多方然后进行通信用的，即把数据从以放传递给另一方。以前学习编写的程序都是单机的，即不能和其他电脑上的程序进行通讯。为了让不同的电脑运行的软件，之间能够互相传递数据，就需要借助网络的功能。","text":"1. 基本概念1.1 网络通信概述主要分为udp和tcp， udp比较简单，tcp比较难 ** 网络**就是一种辅助双方或者多方能够连接在一起的工具 使用网络的目的：数据交换就是为了联通多方然后进行通信用的，即把数据从以放传递给另一方。以前学习编写的程序都是单机的，即不能和其他电脑上的程序进行通讯。为了让不同的电脑运行的软件，之间能够互相传递数据，就需要借助网络的功能。 所谓的网络编程就是让不同的电脑上的软件能够进行数据传递，即进程之间的通信。![1-1 不同主机通信](1-1 不同主机通信.JPG) 1.2 IP地址ip地址：类似于192.168.1.1这种，用于标记网络上的一台电脑。标记数据给谁，ip地址相当于收件地址。在本地局域网内是唯一的。![1-2 ip地址](\\python-03-网络编程\\1-2 ip地址.JPG) 1.3 windows查看网卡信息linux： ifconfig 关闭网卡：sudo ifconfig 查看得到的出了lo之外的名字 down 开启网卡：sudo ifconfig ens40 upwin+R: 搜索cmd，进入输入ipconfig 1.4 ip地址的分类-ipv4和ipv6介绍ip v4: ip version 4, ip网络标记的第4个版本。特征 xxxx.xxx.xxx.xxx每个位置最大位256。总共用256*256*256*256个版本。但目前已经没有ipv4的地址号。ip v6: 但目前还没有在主流中使用，因为使用ipv6的话，需要修改很多之前已经建设过的东西。 目前所讲的ip地址一般还是指ipv4，之后笔记中所提到的ip相关知识也是ipv4相关。 ip地址的组成192.168.33.xx: 用2进制表示，那每一位有8个位置。 A类：第一位0开头，第一位是网络号，后三位是主机号。B类： 第一位10开头，前两个是网络号，后两个是主机号。C类： 第一位110开头，前三个是网络号，后一个是主机号。网络号相同才能互相传输消息。这样总共有254个主机号（0与2不可以使用）。这样明显是不够用的。C类是最常用的。D类：第一位1110开头，是专门保留的地址，多倍用在多点广播(multicast)中。![1-3 ip地址的分类](D:\\blog\\hexoblog\\source_posts\\python-03-网络编程\\1-3 ip地址的分类.JPG) 1.5 (重点)端口 desk portip地址用于确认电脑，端口用于确认进程（即哪一个程序）。 12345dest ip:192.168.1.2 #目的ipsrc ip: 192.168.1.1 #源ip，用于回复信息desk port：7788 #目标端口src port: 4567 #源端口，用于回复信息content:你好啊 1.6 端口分类：知名端口，动态端口进程是运行之后的程序。 端口主要分为知名端口和动态端口知名端口（well known prots）: 是众所周知的端口号，范围从0到1023。类似于报警打110，救护车打112这种，大家都知道的号码。 1280端口分配给HTTP服务21端口分配给FTP服务 动态端口：范围从1024到65535。它一般不固定分配某种服务，而是动态分配。 动态分配是指当一个系统程序或应用程序需要网络通信时，它向主机申请一个端口，主机从可用的端口号中分配一个供它使用。当这个程序关闭时，同时也就释放了所占用的端口号。 1.7 socket 介绍在一台电脑上可以通过进程号（PID）来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我么解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用进程。利用ip地址+协议+端口就可以标识网络进程了，网络中的进程通信就可以利用这个标志与其他进程进行交互。 socket（套接字）是进程间通信的一种方式，它与其他进程间通信的一个主要不同是：它能实现不同主机间的进程间通信，我们网络上各种各样的服务大多都是基于Socket来完成通信的。例如网页，QQ聊天，收发email等。 在python中，使用socket模块的函数socket就可以完成： 12import socketsocket.socket(AddressFamily(标记ipv4),Type(udp还是tcp)) 说明： AddressFamily: 可以选择AF_INET(用于Internet进程间通信)或者AF_UNIX(用于同一台机器进程间通信），实际工作中常用AF_INET Type: 套接字类型，可以是SOCK_STREAM（ 流式套接字，主要用于TCP协议）或者SOCK_DGRAM（数据报套接字，主要用于UDP协议） 创建一个tcp socket 123456789import socket#创建tcp的套接字s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)# ...这里时使用套接字的功能（省略）# 不用的时候，关闭套接字s.close() 创建一个udp socket 123456789import socket# 创建udp套接字s = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)# 这里是使用套接字的功能（省略）# 不用的时候，关闭套接字s.close() 说明： 套接字使用流程与文件的使用流程类似：创建，使用它收发数据，关闭套接字 2. udp2.1 udp发送数据demo2.2 关闭VMware的虚拟网卡（了解）2.3 udp发送数据的强调2.4 （重点）运行python程序以及python交互模式，encode编码，发送udp的练习2.5 （重点）接收udp数据2.6 （重点）端口绑定的问题2.7 网络中重要概念复习2.8 输入对方ip、port、全双工、半双工、单工等2.9 案例：udp聊天器3. tcp客户端3.1 tcp介绍3.2 （重点）tcp客户端4. tcp服务器5. tcp下载文件5.1 案例：下载文件5.2 只是点快速总结，listen里的参数5.3 QQ不绑定端口，知识点复习","categories":[],"tags":[]},{"title":"python 网络编程","slug":"python 网络编程","date":"2020-02-15T19:27:25.000Z","updated":"2020-02-16T14:30:27.504Z","comments":true,"path":"2020/02/15/python 网络编程/","link":"","permalink":"https://cedarrr.github.io/Cedarrr.github.io/2020/02/15/python 网络编程/","excerpt":"1. 基本概念1.1 网络通信概述主要分为udp和tcp， udp比较简单，tcp比较难 ** 网络**就是一种辅助双方或者多方能够连接在一起的工具 使用网络的目的：数据交换就是为了联通多方然后进行通信用的，即把数据从以放传递给另一方。以前学习编写的程序都是单机的，即不能和其他电脑上的程序进行通讯。为了让不同的电脑运行的软件，之间能够互相传递数据，就需要借助网络的功能。","text":"1. 基本概念1.1 网络通信概述主要分为udp和tcp， udp比较简单，tcp比较难 ** 网络**就是一种辅助双方或者多方能够连接在一起的工具 使用网络的目的：数据交换就是为了联通多方然后进行通信用的，即把数据从以放传递给另一方。以前学习编写的程序都是单机的，即不能和其他电脑上的程序进行通讯。为了让不同的电脑运行的软件，之间能够互相传递数据，就需要借助网络的功能。 所谓的网络编程就是让不同的电脑上的软件能够进行数据传递，即进程之间的通信。![1-1 不同主机通信](D:\\blog\\hexoblog\\source_posts\\python-03-网络编程\\1-1 不同主机通信.JPG) 1.2 IP地址ip地址：类似于192.168.1.1这种，用于标记网络上的一台电脑。标记数据给谁，ip地址相当于收件地址。在本地局域网内是唯一的。![1-2 ip地址](D:\\blog\\hexoblog\\source_posts\\python-03-网络编程\\1-2 ip地址.JPG) 1.3 windows查看网卡信息linux： ifconfig 关闭网卡：sudo ifconfig 查看得到的出了lo之外的名字 down 开启网卡：sudo ifconfig ens40 upwin+R: 搜索cmd，进入输入ipconfig 1.4 ip地址的分类-ipv4和ipv6介绍ip v4: ip version 4, ip网络标记的第4个版本。特征 xxxx.xxx.xxx.xxx每个位置最大位256。总共用256*256*256*256个版本。但目前已经没有ipv4的地址号。ip v6: 但目前还没有在主流中使用，因为使用ipv6的话，需要修改很多之前已经建设过的东西。 目前所讲的ip地址一般还是指ipv4，之后笔记中所提到的ip相关知识也是ipv4相关。 ip地址的组成192.168.33.xx: 用2进制表示，那每一位有8个位置。 A类：第一位0开头，第一位是网络号，后三位是主机号。B类： 第一位10开头，前两个是网络号，后两个是主机号。C类： 第一位110开头，前三个是网络号，后一个是主机号。网络号相同才能互相传输消息。这样总共有254个主机号（0与2不可以使用）。这样明显是不够用的。C类是最常用的。D类：第一位1110开头，是专门保留的地址，多倍用在多点广播(multicast)中。![1-3 ip地址的分类](D:\\blog\\hexoblog\\source_posts\\python-03-网络编程\\1-3 ip地址的分类.JPG) 1.5 (重点)端口 desk portip地址用于确认电脑，端口用于确认进程（即哪一个程序）。 12345dest ip:192.168.1.2 #目的ipsrc ip: 192.168.1.1 #源ip，用于回复信息desk port：7788 #目标端口src port: 4567 #源端口，用于回复信息content:你好啊 1.6 端口分类：知名端口，动态端口进程是运行之后的程序。 端口主要分为知名端口和动态端口知名端口（well known prots）: 是众所周知的端口号，范围从0到1023。类似于报警打110，救护车打112这种，大家都知道的号码。 1280端口分配给HTTP服务21端口分配给FTP服务 动态端口：范围从1024到65535。它一般不固定分配某种服务，而是动态分配。 动态分配是指当一个系统程序或应用程序需要网络通信时，它向主机申请一个端口，主机从可用的端口号中分配一个供它使用。当这个程序关闭时，同时也就释放了所占用的端口号。 1.7 socket 介绍在一台电脑上可以通过进程号（PID）来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我么解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用进程。利用ip地址+协议+端口就可以标识网络进程了，网络中的进程通信就可以利用这个标志与其他进程进行交互。 socket（套接字）是进程间通信的一种方式，它与其他进程间通信的一个主要不同是：它能实现不同主机间的进程间通信，我们网络上各种各样的服务大多都是基于Socket来完成通信的。例如网页，QQ聊天，收发email等。 在python中，使用socket模块的函数socket就可以完成： 12import socketsocket.socket(AddressFamily(标记ipv4),Type(udp还是tcp)) 说明： AddressFamily: 可以选择AF_INET(用于Internet进程间通信)或者AF_UNIX(用于同一台机器进程间通信），实际工作中常用AF_INET Type: 套接字类型，可以是SOCK_STREAM（ 流式套接字，主要用于TCP协议）或者SOCK_DGRAM（数据报套接字，主要用于UDP协议） 创建一个tcp socket 123456789import socket#创建tcp的套接字s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)# ...这里时使用套接字的功能（省略）# 不用的时候，关闭套接字s.close() 创建一个udp socket 123456789import socket# 创建udp套接字s = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)# 这里是使用套接字的功能（省略）# 不用的时候，关闭套接字s.close() 说明： 套接字使用流程与文件的使用流程类似：创建，使用它收发数据，关闭套接字 2. udp2.1 udp发送数据demo2.2 关闭VMware的虚拟网卡（了解）2.3 udp发送数据的强调2.4 （重点）运行python程序以及python交互模式，encode编码，发送udp的练习2.5 （重点）接收udp数据2.6 （重点）端口绑定的问题2.7 网络中重要概念复习2.8 输入对方ip、port、全双工、半双工、单工等2.9 案例：udp聊天器3. tcp客户端3.1 tcp介绍3.2 （重点）tcp客户端4. tcp服务器5. tcp下载文件5.1 案例：下载文件5.2 只是点快速总结，listen里的参数5.3 QQ不绑定端口，知识点复习","categories":[],"tags":[]},{"title":"UI设计学习","slug":"UI设计学习","date":"2020-02-09T11:34:19.000Z","updated":"2020-02-15T19:28:35.190Z","comments":true,"path":"2020/02/09/UI设计学习/","link":"","permalink":"https://cedarrr.github.io/Cedarrr.github.io/2020/02/09/UI设计学习/","excerpt":"新建一个文件： alt+n自动填色： alt+delete","text":"新建一个文件： alt+n自动填色： alt+delete 缩放至100% ： ctrl+1取消选区： ctrl+D调整图层顺序： ctrl+]/[视图的缩放：ctrl+ +/-抓手：空格选定图片放大缩小： ctrl+t合并图层：ctrl+e 网页设计一定要用矢量图：矢量会保留很好的属性，位图就会把很少的图标直接放大。 2. 矢量形状布尔运算做形状运算必须要在同一个图层上。图层颜色随着上方的颜色改变。第一个移动工具，只能整个图层一起移动。用小黑则可以每个物件单独移动。所以如果还没有确定的合并性状可以先合并图层，用移动按钮一起动，在确定图形之后再合并图片。形状运算： 加法： shift 减法： alt #","categories":[],"tags":[]},{"title":"javascript 学习笔记","slug":"javascript-学习笔记","date":"2020-02-08T22:22:14.000Z","updated":"2020-02-08T22:22:14.414Z","comments":true,"path":"2020/02/08/javascript-学习笔记/","link":"","permalink":"https://cedarrr.github.io/Cedarrr.github.io/2020/02/08/javascript-学习笔记/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Python 解释器,装饰器","slug":"python 01 装饰器解释器","date":"2020-01-18T20:28:31.000Z","updated":"2020-02-15T19:23:41.869Z","comments":true,"path":"2020/01/18/python 01 装饰器解释器/","link":"","permalink":"https://cedarrr.github.io/Cedarrr.github.io/2020/01/18/python 01 装饰器解释器/","excerpt":"1. 基本知识1.1 解释器python解释器在加载.py文件中的代码时，会对内容进行编码（默认ascill)，所以需要在代码中加入使用utf-8解释器的代码。 1234#!/usr/bin/env python# -*- coding: utf-8 -*- print` `\"你好，世界\"","text":"1. 基本知识1.1 解释器python解释器在加载.py文件中的代码时，会对内容进行编码（默认ascill)，所以需要在代码中加入使用utf-8解释器的代码。 1234#!/usr/bin/env python# -*- coding: utf-8 -*- print` `\"你好，世界\" 1.2 用户输入注意在python2.x中尽量使用raw_input因为它会自动把用户的输入的东西存为str的格式，相当于python3当中的input。 12#raw_input仅仅只在python2.x里面有用name = raw_input(\"What is your name?\") 1.3 pycharm设置每次创建新py文件的模板view-&gt;appearance-&gt;toolbar，点击出现菜单里面的扳手符号。editor-&gt;file and code templates 1.4 用户输入这个代码不能在pycharm环境下使用，但在cmd中是可以的。 12345678#!/usr/bin/env python #_*_coding:utf-8_*_import getpassname = raw_input(\"What is your name?\")pwd=getpass.getpass(\"password:\")print(\"Hello \" + name )print(pwd) 1.5 模块初识 创建的文件名不可以与导入的库名相同，例如创建的文件叫sys那么在import sys的时候，会先在当前目录下寻找，就找到了自己创建的文件。在python2.x里会报错，但python3.x好像已经修复了这个问题。但尽量还是不要使用。 sys模块 1234567891011import sys# 打印环境变量print(sys.path)# 在pycharm中打印绝对路径# 如果是在cmd下面，打印文件名并以列表中的一项这种形式出现# python sys_mod.py 1 2 3# 结果会出现['sys_mod.py','1','2','3']# print(sys.argv[2])则会取出2这个字符print(sys.argv) os模块： 实现与系统的交互 12345# 实现与系统的交互import osos.system(\"dir\") # os.system 执行命令，不保存结果os.popen(\"dir\") # os.popen执行命令，并把结果存在一个地址，会返回地址 1.6 pyc文件lib/_pycache_文件夹中会存放pyc文件 编译型语言：C语言。就是在程序执行之前，会先同各国编译器对程序执行一个编译的过程，把程序转变为机器语言，运行时就不需要编译，速度更快。解释型语言：Python, Ruby。没有编译的过程，而是在程序运行的时候，通过解释器对程序逐行做出解释，然后直接运行。 随着Java等基于虚拟机的语言的兴起，语言不可以再被直接分为解释型和编译型这两种。以Java为例，Java首先是通过编译器编译成字节码文件，然后在运行时通过解释器给解释成机器文件，所以说Java是一种先编译后解释的语言。 在命令行中输入python hello.py的时候，其实是激活了Python的解释器告诉解释器要开始工作了。可是在“解释之前”执行的第一项工作其实和java是一样的，就是编译。 python的运行过程当python程序运行的时候，编译的结果是保存在位于内存中的PyCodeObject中，当python程序运行结束时，python解释器九江PyCodeObject写回到pyc文件中。当Python二次运行的时候，程序会先在硬盘中寻找pyc文件，如果找到，就直接写入否则就重复上面的过程。在找到pyc文件的同时，还会比较代码和pyc文件的更新时间，如果不一致还是会重复上述过程所以pyc文件其实似乎PyCodeObject的一种持久化保存方式。 1.7 基础的代码 列表的复制要用list_name.copy()而不要直接new_list=old_list。 字典的多级目录 12345678910111213data=&#123; 'new york':&#123; 'university':&#123; 'fashion':[\"left\",\"right\"] &#125; &#125;, 'uk':&#123; \"london\":[\"kings cross station\"] &#125;&#125;print(data['new york'][\"university\"][\"boston\"][0]) ## 打印结果是left 函数 匿名函数 ：就是不需要显式的指定函数 12345678910111213# 普通函数def calc(n): return n**nprint(calc(10))# 匿名函数calc=lambda n::n**nprint(calc(10))# 匿名函数一般会搭配其他的函数使用res=map(lambda x:x**2,[1,5,7,4,8])for i in res: print(i) 递归函数： 在函数内部调用自己的函数 递归必须有一个明确的结束条件 每次进入更深一层递归时，问题规模比上次递归都应有所减少 递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出） 1234567def calc(n): print(n) if int(n/2)&gt;0: # 这里必须要加int， 要不出现小数就永元不会达到这个条件 return calc(n/2) else: return 1calc(8) 递归应用于二分查找法 123456789101112131415161718192021def binary_search(dataset, find_num): print(dataset) if len(dataset) &gt; 1: mid = int(len(dataset) / 2) if dataset[mid] == find_num: # find it print(\"找到数字\", dataset[mid]) elif dataset[mid] &gt; find_num: # 找的数在mid左面 print(\"\\033[31;1m找的数在mid[%s]左面\\033[0m\" % dataset[mid]) return binary_search(dataset[0:mid], find_num) else: # 找的数在mid右面 print(\"\\033[32;1m找的数在mid[%s]右面\\033[0m\" % dataset[mid]) return binary_search(dataset[mid + 1:], find_num) else: if dataset[0] == find_num: # find it print(\"找到数字啦\", dataset[0]) else: print(\"没的分了,要找的数字[%s]不在列表里\" % find_num)data = [1, 3, 6, 7, 9, 12, 14, 16, 17, 18, 20, 21, 22, 23, 30, 32, 33, 35]binary_search(data, 66) 高阶函数：一个函数可以接收另一个函数作为参数，这种函数就称之为高阶函数。12345def add(x,y,f): return f(x)+f(y)res=add(3,-6,abs)print(res) 1.8 内置参数all(iterablei):如果可迭代对象里面，所有对象都为真，结果就是真。（数字里非0即为真）any(iterablei):如果可迭代对象里面，有真即为真。 1.9 软件目录结构规范设计一个层次清晰的目录结构，就是为了达到一下两点： 可读性高：不熟悉这个项目代码的人，一眼就能看懂目录结构，直到程序启动脚本是哪个，测试目录在哪里，配置文件在哪里等，从而非常快速的了解这个项目。 可维护性高：定义好组织规则后，维护者就能很明确地直到，新增地哪个文件和代码应该放在什么目录之下。这个好处是，随着时间的推移，代码/配置的规模增加，项目结构不会混乱，依然能组织好。 假设你的项目名为foo, 我比较建议的最方便快捷目录结构这样就足够了: 12345678910111213141516171819Foo/|-- bin/| |-- foo||-- foo/| |-- tests/| | |-- __init__.py| | |-- test_main.py| || |-- __init__.py| |-- main.py||-- docs/| |-- conf.py| |-- abc.rst||-- setup.py|-- requirements.txt|-- README 简要解释一下: bin/: 存放项目的一些可执行文件，当然你可以起名script/之类的也行。 foo/: 存放项目的所有源代码。(1) 源代码中的所有模块、包都应该放在此目录。不要置于顶层目录。(2) 其子目录tests/存放单元测试代码； (3) 程序的入口最好命名为main.py。 docs/: 存放一些文档。 setup.py: 安装、部署、打包的脚本。 requirements.txt: 存放软件依赖的外部Python包列表。 README: 项目说明文件。 除此之外，有一些方案给出了更加多的内容。比如LICENSE.txt,ChangeLog.txt文件等，我没有列在这里，因为这些东西主要是项目开源的时候需要用到。如果你想写一个开源软件，目录该如何组织，可以参考这篇文章。 下面，再简单讲一下我对这些目录的理解和个人要求吧。 关于README的内容 这个我觉得是每个项目都应该有的一个文件，目的是能简要描述该项目的信息，让读者快速了解这个项目。 它需要说明以下几个事项： 软件定位，软件的基本功能。 运行代码的方法: 安装环境、启动命令等。 简要的使用说明。 代码目录结构说明，更详细点可以说明软件的基本原理。 常见问题说明。 我觉得有以上几点是比较好的一个README。在软件开发初期，由于开发过程中以上内容可能不明确或者发生变化，并不是一定要在一开始就将所有信息都补全。但是在项目完结的时候，是需要撰写这样的一个文档的。 可以参考Redis源码中Readme的写法，这里面简洁但是清晰的描述了Redis功能和源码结构。 关于requirements.txt和setup.py setup.py一般来说，用setup.py来管理代码的打包、安装、部署问题。业界标准的写法是用Python流行的打包工具setuptools来管理这些事情。这种方式普遍应用于开源项目中。不过这里的核心思想不是用标准化的工具来解决这些问题，而是说，一个项目一定要有一个安装部署工具，能快速便捷的在一台新机器上将环境装好、代码部署好和将程序运行起来。 我刚开始接触Python写项目的时候，安装环境、部署代码、运行程序这个过程全是手动完成，遇到过以下问题: 安装环境时经常忘了最近又添加了一个新的Python包，结果一到线上运行，程序就出错了。 Python包的版本依赖问题，有时候我们程序中使用的是一个版本的Python包，但是官方的已经是最新的包了，通过手动安装就可能装错了。 如果依赖的包很多的话，一个一个安装这些依赖是很费时的事情。 新同学开始写项目的时候，将程序跑起来非常麻烦，因为可能经常忘了要怎么安装各种依赖。 setup.py可以将这些事情自动化起来，提高效率、减少出错的概率。”复杂的东西自动化，能自动化的东西一定要自动化。”是一个非常好的习惯。 setuptools的文档比较庞大，刚接触的话，可能不太好找到切入点。学习技术的方式就是看他人是怎么用的，可以参考一下Python的一个Web框架，flask是如何写的: setup.py 当然，简单点自己写个安装脚本（deploy.sh）替代setup.py也未尝不可。 requirements.txt这个文件存在的目的是: 方便开发者维护软件的包依赖。将开发过程中新增的包添加进这个列表中，避免在setup.py安装依赖时漏掉软件包。 方便读者明确项目使用了哪些Python包。 这个文件的格式是每一行包含一个包依赖的说明，通常是flask&gt;=0.10这种格式，要求是这个格式能被pip识别，这样就可以简单的通过 pip install -r requirements.txt来把所有Python包依赖都装好了。具体格式说明： 点这里。 关于配置文件的使用方法注意，在上面的目录结构中，没有将conf.py放在源码目录下，而是放在docs/目录下。很多项目对配置文件的使用做法是: 配置文件写在一个或多个python文件中，比如此处的conf.py。 项目中哪个模块用到这个配置文件就直接通过import conf这种形式来在代码中使用配置。 这种做法我不太赞同: 这让单元测试变得困难（因为模块内部依赖了外部配置） 另一方面配置文件作为用户控制程序的接口，应当可以由用户自由指定该文件的路径。 程序组件可复用性太差，因为这种贯穿所有模块的代码硬编码方式，使得大部分模块都依赖conf.py这个文件。 所以，我认为配置的使用，更好的方式是， 模块的配置都是可以灵活配置的，不受外部配置文件的影响。 程序的配置也是可以灵活控制的。能够佐证这个思想的是，用过nginx和mysql的同学都知道，nginx、mysql这些程序都可以自由的指定用户配置。所以，不应当在代码中直接import conf来使用配置文件。上面目录结构中的conf.py，是给出的一个配置样例，不是在写死在程序中直接引用的配置文件。可以通过给main.py启动参数指定配置路径的方式来让程序读取配置内容。当然，这里的conf.py你可以换个类似的名字，比如settings.py。或者你也可以使用其他格式的内容来编写配置文件，比如settings.yaml之类的。 bin/atm.py 12345678910111213141516171819# 获取当前文件路径，以获得其他文件夹下想要引用文件的路径# 返回当前文件的相对路径，在pycharm里面显示为绝对路径，但实际为相对import osimport sys# os.path.dirname 仅要路径名，不要文件名# os.path.abspath 根据相对路径，获得绝对路径BASE_DIR=os.path.dirname(os.path.dirname(os.path.abspath(__file__)))# 添加环境变量sys.path.append(BASE_DIR)import conf,corefrom conf import settingsfrom core import mainmain.login() core/main.py 123# 一般不在main里面写主逻辑def login(): print(\"Welcome to my atm\") 22.1 装饰器 decorator装饰器： 定义：本质是函数，关键语法都是用def定义的。是用来装饰其他函数，为其他函数添加附加功能。原则：1. 不能修改被装饰的函数的源代码。2. 不能修改被装饰的函数的调用方式。也就是装饰器对被修改的函数是完全透明的。 实现装饰器的知识储备：高阶函数+嵌套函数-》装饰器 函数即“变量” 高阶函数 嵌套函数 函数即变量函数就像变量一样，当创建函数的时候，就在内存中划分一个空间装函数体，函数名就相当于变量名是个门牌号。python中的内存回收机制是当没有门牌号的时候，里面的值就会被清空。匿名函数没有函数名，所以立刻会被回收。但如果匿名函数赋给给某个值，就相当于给予了门牌号。 高阶函数 把一个函数名当作实参传给另外一个函数 （在步修改被装饰函数源代码的情况下为其添加功能） 返回值中包含函数名 理解装饰器的作用方法. 123456789101112131415def bar(): print(\"in the bar\")def test1(func): print(func) return func #print(test1(bar)) # 注意这里要传bar而非bar(),因为bar是门牌号 # 而bar()是bar这个函数的运行结果，如果传bar() # 那么传给test1的就不是函数了bar=test1(bar) #这里就相当于改写了门牌号bar指向的地址bar()# output#&lt;function bar at 0x02BFE7C0&gt;#&lt;function bar at 0x02BFE7C0&gt; 嵌套函数函数的嵌套是在一个函数内容，def一个新的函数，而不只是单纯的调用某个函数。 123456def foo(): print(\"in the foo\") def bar(): # 这个函数具有局部变量的特性，不能在外部被调用。 print(\"in the bar\") bar()foo() 当没有参数的时候，装饰器的使用 12345678910111213141516171819202122import timedef timer(func): #timer(test1) func=test1 def timer2(): start_time=time.time() func() # run test1() end_time=time.time() print(\"the func run time is %s\"%(end_time-start_time)) return timer2 # 返回地址@timerdef test1(): time.sleep(3) print(\"in the test1\")# 把地址赋给这个原来的门牌号# @timer写在上面就相当于这一步# test1=timer(test1)test1() # 这里实际上是在执行timer2#output#in the test1#the func run time is 3.0004637241363525 非固定参数，装饰器。*args, **kwargs是非固定参数，此时，不管被修饰的函数有几个参数，都可以使用了 123456789101112131415import timedef timer(func): #timer(test1) func=test1 def timer2(*args,**kwargs): # *args, **kwargs是非固定参数 start_time=time.time() func(*args,**kwargs) # run test1() end_time=time.time() print(\"the func run time is %s\"%(end_time-start_time)) return timer2 # 返回地址@timerdef test1(): time.sleep(3) print(\"in the test1\")@timer # test2=timer(test2)=timer2 test2(name)=timer2(name)def test2(name): print(\"test2\",name) 进阶版，根据不同的页面，用不同的方式进行验证 123456789101112131415161718192021222324252627282930313233343536373839user,passwd=\"alex\",\"abc123\"def auth(auth_type): #print(\"auth func\",auth_type) def outer_wrapper(func): def wrapper(*args, **kwargs): #print(\"auth func args\",*args, **kwargs) username = input(\"Username:\").strip() password = input(\"Password:\").strip() if auth_type == \"local\": if user == username and passwd == password: print(\"\\033[32:1mUser has passed authentication\\033[Om\") # 以绿色的颜色打印一句登陆成功的提示语 res = func(*args, **kwargs) # 这就就相当于func在执行，但由于这个值没有传递给任何变量，所以如果原func是有返回值的 # 在这里就会丢失，所以需要在这里把res赋值 print(\"---after authentication\") return res else: exit(\"\\033[31:1mInvalid username or passwd\\033[Om\") # 以红色的颜色打印一句登陆成功的提示语 elif auth_type==\"ldap\": print(\"get ldap\") return wrapper return outer_wrapperdef index(): print(\"Welcome to index page\")@auth(auth_type=\"local\") #希望实现home页面用本地的文件验证def home(): print(\"welcome to home page\") return \"from home\"@auth(auth_type=\"ldap\") # bbs用ldap的方法验证def bbs(): print(\"welcome to bbs page\")index()print(home()) # 在这里调用hone，相当于调用wrapperbbs() 2.2 生成器 generator2.3.1 列表生成式 12345&gt;&gt;&gt; [i*2 for i in range(10)][0, 2, 4, 6, 8, 10, 12, 14, 16, 18]#还可以加入函数&gt;&gt;&gt; [func(i) for i in range(10)] 2.3.2 生成器 生成器： 只有在调用时才会生成象映的数据 只记录当前位置 只有一个__next__()方法（此方法用于python3.x，python2.x用next() 通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅只访问前面几个元素，后面的空间就被白白浪费了。所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环过程中不断推算出后续的元素呢？这样就不必创建完整的list， 从而节省大量的空间。在python中，这样一边循环一边计算的机器，称为生成器generator。 要创建一个generator, 123456789101112&gt;&gt;&gt; b=(i*2 for i in range(10))&gt;&gt;&gt; b&lt;generator object &lt;genexpr&gt; at 0x01605808&gt;&gt;&gt;&gt; b=((i*2 for i in range(5)))&gt;&gt;&gt; for i in b: print(i)0246810 生成器不支持直接根据index，调取相关序列的值，如b[2]，不可以用切片下标等方式来取值。生成器用for循环这种方式一个一个取，才可以取出来。生成器节省空间的方式就是只记住当前位置。可以利用b.__next__()这种方式，调用当前位置的下一个，且不能返回到前一个。 generator非常强大，如果推算的算法比较复杂。用类似列表生成式的for循环无法实现的时候，还可以用函数来实现，例如斐波那契数列（Fibonacci）。yield相当于return会返回值 1234567891011121314151617181920212223242526272829303132def fib(max1): n, a, b = 0, 0, 1 while n &lt; max1: #print(b) yield b #注意这里要用yield。此时这段代码就是generator而非函数。 a, b = b, a + b n = n + 1 return '--done--' # 错误的时候，返回的值for i in fib(3): print(i)#output#1#1#2f=fib(3)print(f.__next__()) #这里用__next__()取下面的值print(\"===========\") #生成器可以随时停止，这有利于在单线程的情况下实现多线程。print(f.__next__())print(f.__next__())print(f.__next__()) #这里取值，超过了范围，就会报错#1#===========#1#2# Traceback (most recent call last):# File \"D:/school/mooc/untitled1/day2/generator1.py\", line 14, in &lt;module&gt;# print(f.__next__())# StopIteration: --done-- 利用try except来捕获错误。 123456789f=fib(3)while True: try: x=next(f) print('g:',x) except StopIteration as e: print(\"Generator return value:\",e.value) break 还可以利用生成器在单线程的情况下可以实现多线程的效果（即协程），这里的代码就是异步IO的雏形。xx.send()的作用是resumes the generator and &quot;sends&quot; a value that becomes the result of the current yield-expression 1234567891011121314151617181920import timedef consumer(name): print(\"%s 准备吃包子啦！\" %name) while True: baozi=yield print(\"包子[%s]来了，被[%s]吃了\" %(baozi,name))def producer(name): c=consumer('A') c2=consumer('B') c.__next__() #要先next一下，走到第一次返回的地方，为了打印“准备吃包子”这句话 c2.__next__() print(\"要开始做包子啦！\") for i in range(10): time.sleep(1) print(\"做了两个包子！\") c.send(i) #把 i的值传入，被yield接收 c2.send(i)producer(\"alex\") 2.3 迭代器 Iterator一般可以直接用于for循环的数据类型有一下两种： 集合数据类型，如list, tuple, dict, set, str等 generator,包括生成器和带yield的generator function这些可以直接作用于for循环的对象可以统称为可迭代对象：Iterable。可以使用isinstance()来判断一个对象是否是Iterable对象。12345&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance(\"123\",Iterable)True&gt;&gt;&gt; isinstance(123,Iterable)False 而生成器不但可以作用于for循环，还可以被next()函数不断调用病返回下一个值，知道最后抛出StopIteration错误表示无法继续返回下一个值了。 可以被next()函数调用并不断返回下一个值得对象称为迭代器：Iterator 生成器都是Iterator 对象，但list, dict， str虽然是Iterable, 但却不是Iterator。因为python的Iterator对象表示的是一个数据流。Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看成是一个有序序列，但我们却不能提前直到序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。 把list, dict, str等iterable变成iterator可以使用iter()函数。 Iterator甚至可以表示一个无限大的数据流，例如全体自然数，而使用list是永远不可能存储全体自然数的。 2.4 Json &amp; pickle数据序列化2.4.1 Json Json正在成为主流的不同平台之间简单数据的交换工具。之前的xml主要的作用也是不同的语言之间进行数据交互，现在正在被json取代。一个文件只能dump一次，也只能Load一次 123456789101112131415# 不标准做法，应尽量避免# 写入文件info=&#123; 'name':'alex', 'age':22&#125;f=open(\"test.test\",\"w\")f.write(str(info))f.close()# 得到已变成字符串的字典中的数据值f=open(\"test.test\",\"r\")data=eval(f.read()) #eval能返回传入字符串的表达式的结果。f.close()print(data['age']) 引入Json 123456789101112131415#json序列化import jsoninfo=&#123; 'name':'alex', 'age':22&#125;f=open(\"test.txt\",\"w\")f.write(json.dumps(info))f.close()#json返序列化import jsonf = open(\"test.txt\",\"r\")data = json.loads(f.read())print(data[\"age\"]) 2.4.2 Pickle pickle与json的用法几乎完全一致。但pickel可以序列化函数等更复杂的数据类型。java只认识json，不认识pickle。 1234567891011121314151617181920212223242526#pickle序列化import pickledef sayhi(name): print(\"hello\",name)info=&#123; 'name':'alex', 'age':22, \"func\":sayhi&#125;f=open(\"test.txt\",\"wb\") #以二进制的形式读入文件，pickle要求# f.write(pickle.dumps(info)) #与下面的一致pickle.dump(info,f) f.close()#pickle返序列化import pickle#这里只需要函数名一样，里面的内容不一样都可以#pickle序列化的是整个对象，而非仅仅只是个内存地址def sayhi(name): print(\"hello\",name)f = open(\"test.txt\",\"rb\") #以二进制的形式读入#data = pickle.loads(f.read())与下面一致data = pickle.load(f)print(data[\"func\"](\"alex\")) Reference: 课程网页：https://www.cnblogs.com/alex3714/articles/5465198.html 装饰器，迭代器和生成器：https://www.cnblogs.com/alex3714/articles/5765046.html 内置函数：https://www.runoob.com/python/python-built-in-functions.html python中eval的强大与危害：https://blog.csdn.net/liuchunming033/article/details/87643041","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://cedarrr.github.io/Cedarrr.github.io/tags/python/"}]},{"title":"NGS Reading","slug":"NGS-Reading","date":"2020-01-12T22:42:50.000Z","updated":"2020-01-12T22:47:30.945Z","comments":true,"path":"2020/01/12/NGS-Reading/","link":"","permalink":"https://cedarrr.github.io/Cedarrr.github.io/2020/01/12/NGS-Reading/","excerpt":"","text":"","categories":[],"tags":[{"name":"bioinformatics","slug":"bioinformatics","permalink":"https://cedarrr.github.io/Cedarrr.github.io/tags/bioinformatics/"},{"name":"reading","slug":"reading","permalink":"https://cedarrr.github.io/Cedarrr.github.io/tags/reading/"}]},{"title":"Reading list","slug":"reading-list","date":"2020-01-12T20:25:36.000Z","updated":"2020-01-12T21:11:35.884Z","comments":true,"path":"2020/01/12/reading-list/","link":"","permalink":"https://cedarrr.github.io/Cedarrr.github.io/2020/01/12/reading-list/","excerpt":"Next generation genomics: Background Reading list – Useful reference collections A collection from the journal Bioinformatics is at http://www.oxfordjournals.org/our_journals/bioinformatics/nextgenerationsequencing.html Briefings in Bioinformatics has a special issue on 2nd generation sequencing http://bib.oxfordjournals.org/content/11/5.toc Frontiers in Genetics has a special issue on quality assessment and control of high-throughput sequencing data http://journal.frontiersin.org/ResearchTopic/1683 A list of software tools for NGS is at http://seqanswers.com/forums/showthread.php?t=43","text":"Next generation genomics: Background Reading list – Useful reference collections A collection from the journal Bioinformatics is at http://www.oxfordjournals.org/our_journals/bioinformatics/nextgenerationsequencing.html Briefings in Bioinformatics has a special issue on 2nd generation sequencing http://bib.oxfordjournals.org/content/11/5.toc Frontiers in Genetics has a special issue on quality assessment and control of high-throughput sequencing data http://journal.frontiersin.org/ResearchTopic/1683 A list of software tools for NGS is at http://seqanswers.com/forums/showthread.php?t=43 NGS blogs http://ivory.idyll.org/blog/ http://omicsomics.blogspot.co.uk/ http://pathogenomics.bham.ac.uk/blog/ http://www.rna-seqblog.com/ http://core-genomics.blogspot.co.uk/ http://www.homolog.us/blogs/ https://flxlexblog.wordpress.com/","categories":[],"tags":[{"name":"bioinformatics","slug":"bioinformatics","permalink":"https://cedarrr.github.io/Cedarrr.github.io/tags/bioinformatics/"},{"name":"reading","slug":"reading","permalink":"https://cedarrr.github.io/Cedarrr.github.io/tags/reading/"}]},{"title":"生信入门阅读与理解","slug":"生信入门阅读","date":"2020-01-10T21:19:53.000Z","updated":"2020-02-15T19:29:37.232Z","comments":true,"path":"2020/01/10/生信入门阅读/","link":"","permalink":"https://cedarrr.github.io/Cedarrr.github.io/2020/01/10/生信入门阅读/","excerpt":"2019年，做生信，应该知道的十大经典套路: https://www.jianshu.com/p/84ca0b818574 多组学联合分析：http://www.yingbio.com/article-35507-108404.html","text":"2019年，做生信，应该知道的十大经典套路: https://www.jianshu.com/p/84ca0b818574 多组学联合分析：http://www.yingbio.com/article-35507-108404.html 多层组学整合分析是指对来自不同组学，如基因组学，转录组学，蛋白组学和代谢组学的数据来源进行归一化处理，比较分析应用到同一个课题中。 基因组学（genomics）: 利用高通量测序获取样本中所有功能基因的序列和表达量信息。 转录组学（transcriptomics）：利用高通量测序全面快速地获取某一物种特定器官或组织在某一状态下几乎所有转录本。转录组测序可以检测到所有正在表达的的基因的变化动态。 蛋白组学（proteomics）: 利用HPLC-MSMS技术获取某一时刻样本内所有表达蛋白。蛋白组学是基因表达调控机理研究的一个重要工具。 代谢组学（Metabolomics）: 利用液质联用/气质联用技术研究在某一时刻内所有代谢物。代谢组学放大了基因和蛋白表达的微小变化。反映了机体系统的生理和病理状态。 一句话概括： 基因组学告诉可能发生什么（what possibly happen）, 转录组学告诉你正在发生什么（what probably happen）, 蛋白组学告诉你已经发生什么（what actually happen） 而代谢组学则告诉你什么确实发生了（what happened) chip-seq中的motif分析：https://www.jianshu.com/p/5868a420247c","categories":[],"tags":[{"name":"bioinformatics","slug":"bioinformatics","permalink":"https://cedarrr.github.io/Cedarrr.github.io/tags/bioinformatics/"}]},{"title":"GEO数据挖掘","slug":"01 GEO数据挖掘","date":"2020-01-10T20:40:37.000Z","updated":"2020-01-12T12:35:21.023Z","comments":true,"path":"2020/01/10/01 GEO数据挖掘/","link":"","permalink":"https://cedarrr.github.io/Cedarrr.github.io/2020/01/10/01 GEO数据挖掘/","excerpt":"","text":"01 通用文献阅读及规律02 了解GEO数据库03 数据下载的3种方式 – 得到表达矩阵由于R语言版本高于3.5，需要用新的方式安装GEOquery 123456789101112131415161718192021222324252627if (!requireNamespace(\"BiocManager\", quietly = TRUE)) install.packages(\"BiocManager\")BiocManager::install(version = \"3.10\")biocManager::install(\"GEOquery\")# 获得表达矩阵的两种方式# 1. getGEO# eset这里是个对象,里面包括表达矩阵，芯片如何设计，样本如何分组等信息。 从这个列表中提取出表达矩阵，才能进行后续的操作eset&lt;-getGEO(\"GSE42872\", destdir=\".\", #下载在当前目录 getGPL=F, # 平台信息不要 AnnotGPL=F) # 注释不要b1=exprs(eset[[1]]) # 提取表达矩阵# 2. 从网页里直接下载GEO文件，然后处理# a是一个表达矩阵a=read.table(\"GSE42872_series_matrix.txt.gz\", sep=\"\\t\",quote=\"\",fill=T, comment.char=\"!\",header=T) #不要注释信息，把第一行设置为headera[,1] # a的第一列rownames(a)=a[,1] #把a的行名设为第一列的名字a=a[,-1] #去掉原来的第一列，也就是行名的那一列## 这里b1和处理之后的a是完全相同的东西## getGEO和GEOquery就是做了方法2的代码 用GEOquery从GEO数据库下载数据：http://www.bio-info-trainee.com/bioconductor_China/software/GEOquery.html 04 ID转换技巧大全通常会出现多个探针对应同一个基因，取平均值，最大值，中位值等等，其实一个探针也可以对应多个基因，因为基因家族的问题，基因本身ID就是多种多样的，entrz ID和symbol是最重要的。 我们下载的数据通常使用的是不同的芯片探针，它们有不同的探针ID(probe id)，我们需要把它转化成entrez ID或者是symbol ID 12345678910111213141516# 观察eset列表&gt; eset[[1]]ExpressionSet (storageMode: lockedEnvironment)assayData: 33297 features, 6 samples element names: exprs protocolData: nonephenoData sampleNames: GSM1052615 GSM1052616 ... GSM1052620 (6 total) varLabels: title geo_accession ... cell type:ch1 (34 total) varMetadata: labelDescriptionfeatureData: noneexperimentData: use 'experimentData(object)' pubMedIds: 24469106 Annotation: GPL6244 这个的芯片平台是GPL6244, 需要找到对应的R包。可以直接用搜索，GPL6244 r package或是参考里生信树的文章。找到的生信平台是hugene10sttranscriptcluster。 12345678910111213biocManager::install(\"hugene10sttranscriptcluster.db\")library(hugene10sttranscriptcluster.db)ls(\"package:hugene10sttranscriptcluster.db\") #查看包里包含哪些对象ids=toTable(hugene10sttranscriptclusterSYMBOL) #用toTable函数提取数据集里面的信息&gt; head(ids) probe_id symbol1 7896759 LINC011282 7896761 SAMD113 7896779 KLHL174 7896798 PLEKHN15 7896817 ISG156 7896822 AGRN 查看基因的数量，unique：extract unique elements 是用来去除重复的symbol，只提取不同的元素。length函数统计去重之后的基因数量。 12&gt; length(unique(ids$symbol))[1] 18834 查看每个基因对应的探针。table()可以省成频数统计表，这里就是统计每个基因symbol出现的次数并将其表格化；sort()函数将symbol出现的频率从小到大排序；tail()取最后6个即出现频率最大的6个。 1234&gt; tail(sort(table(ids$symbol))) RPL41 UBTFL1 CDK11B UBE2D3 IGKC LRRFIP1 6 6 8 8 10 10 这里table()是把出现频率相同的探针继续归一，继续表格化。这里18072个基因设计了1个探针，599个基因设计了2个探针…这个表达矩阵中大部分的基因只设计了一个探针。一般基因都会设计很多探针，我们下载的表达矩阵是作者处理之后的，把许多不好的探针都过滤掉了，我们处理作者的数据要默认人家做的是对的，否则就要下载原始数据自己处理。 12345# 找到a1里面probe id里是否在ids里面 &gt; table(rownames(a1) %in% ids$probe_id) FALSE TRUE 13483 19814 #有13483个不在，19814个在dim(a1) # 探针数量，这时有33297个探针 x %in% y表示x的元素在y中吗？然后返回逻辑值。rownames(a1)即表达矩阵a1的行名，是文章数据中所用到的探针idprobe id;ids$probe_id是所有具有对应基因的所有探针。所以返回的true就是文章数据中有对应基因的探针数。 123# 过滤a1里，probe id不在R 包中的数据a1=a1[rownames(a1) %in% ids$probe_id,]dim(a1) #此时探针只剩下了19814个 这里就相当于矩阵取子集，如matrix[2,]意思就是取矩阵matrix的第2行和所有的列。同理，这里的就是取具有对应基因的所有探针，和所有的列。 用match函数把ids里的探针顺序改一下。match（）函数返回的是一个位置向量，该向量记录这第一个参数总每个远在在第2个参数中的位置。所以此时ids里的探针顺序与表达矩阵a1的探针顺序意义对应。 123456789101112131415161718# 使探针顺序与表达矩阵顺序相同ids=ids[match(rownames(a1),ids$probe_id),]&gt; head(ids) probe_id symbol1 7896759 LINC011282 7896761 SAMD113 7896779 KLHL174 7896798 PLEKHN15 7896817 ISG156 7896822 AGRN&gt; head(a1) X.GSM1052615. X.GSM1052616. X.GSM1052617. X.GSM1052618. X.GSM1052619. X.GSM1052620.7896759 8.75126 8.61650 8.81149 8.32067 8.41445 8.452087896761 8.39069 8.52617 8.43338 9.17284 9.10216 9.141207896779 8.20228 8.30886 8.18518 8.13322 8.06453 8.158847896798 8.41004 8.37679 8.27521 8.34524 8.35557 8.444097896817 7.72204 7.74572 7.78022 7.72308 7.53797 7.734017896822 9.19237 9.10929 9.03668 9.94821 9.96994 9.99839 顺序相同就可以通过ids的probe id对表达矩阵进行分类，得到探针列表。将同一个symbol所对应的多个探针分成不同的组，并对每组探针进行统计；计算每组中每行探针表达量的平均值（也就是每个探针在6个样本中表达量的均值rowMeans(x)），再取平均值最大的那个探针作为该symbol所对应的唯一探针，该组中的其他探针过滤掉，这样每个symbol就对应一个探针了，看下代码是如何操作的： 12345678910tmp=by(a1, ids$symbol, function(x) rownames(x)[which.max(rowMeans(x))])# 再把探针列表转换成probeprobes=as.character(tmp)dim(a1) #[1] 19814 6# 过滤有多个探针的基因。a1=a1[rownames(a1) %in% probes,]dim(a1) #[1] 18821 6 by()函数在这里发挥的功能就是将表达矩阵a1中的探针分组，同一个symbol所对应的多个探针分到一组，并对每组探针进行统计得到symbol所对应的唯一探针。所以tmp里放着by()函数的统计结果即每个symbol所对应的唯一探针IDprobe_id，用probes=as.character(tmp)将结果变身为纯字符型向量。 by()函数会分组计算描述性统计量，它可以一次返回若干个统计量。格式为by(data, INDICES, FUN)，其中data是一个数据框或矩阵；INDICES是一个因子或因子组成的列表，定义了分组；FUN是任意函数。by()函数就是根据因子将整个data分组成几个小的data.frame，然后进行运算处理。 这里by(a1,ids$symbol,function(x) rownames(x)[which.max(rowMeans(x))])的第2个参数ids$symbol定义了分组，将第一个参数a1表达矩阵分成了若干个小矩阵，每个小矩阵里存放着同一个symbol所对应的所有探针。但三个参数是我们自己定义的参数：计算每个小矩阵中每行探针表达量的平均值（也就是每个探针在6个样本中表达量的均值rowMeans(x)），再取平均值最大的那个探针作为该symbol, 123456&gt; head(tmp)ids$symbol A1CF A2M A2ML1 A3GALT2 A4GALT A4GNT \"7933640\" \"7960947\" \"7953775\" \"7914643\" \"8076497\" \"8090955\" &gt; head(probes)[1] \"7933640\" \"7960947\" \"7953775\" \"7914643\" \"8076497\" \"8090955\" 05 了解你的表达矩阵06 差异分析07 火山图及热图制作及美化08 KEGG-GO等数据库的注释及GSEA分析09 收尾的几点建议Reference R来完成表达芯片分析全流程：http://www.bio-info-trainee.com/2087.html 生信人的20个语言练习题： http://www.bio-info-trainee.com/3409.html 生信人的20个R语言练习题答案：http://www.bio-info-trainee.com/3415.html 生信人的linux考试： http://www.bio-info-trainee.com/2900.html 黄晶_id视频笔记：https://www.jianshu.com/p/8dd7dc1e1719 刘小泽视频笔记： https://www.jianshu.com/p/993b4022363f 用R 获取芯片探针与基因的对应关系三部曲-bioconductor（常见基因注释平台对应的R包）: http://www.bio-info-trainee.com/1399.html","categories":[],"tags":[{"name":"bioinformatics","slug":"bioinformatics","permalink":"https://cedarrr.github.io/Cedarrr.github.io/tags/bioinformatics/"},{"name":"流程","slug":"流程","permalink":"https://cedarrr.github.io/Cedarrr.github.io/tags/流程/"}]},{"title":"markdown基础语法","slug":"markdown基础语法","date":"2019-12-27T20:40:37.000Z","updated":"2020-01-12T12:25:24.030Z","comments":true,"path":"2019/12/27/markdown基础语法/","link":"","permalink":"https://cedarrr.github.io/Cedarrr.github.io/2019/12/27/markdown基础语法/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960Markdown 目录： [TOC] ### 基础语法Markdown 标题： **# 这是 H1** **## 这是 H2** **### 这是 H3** Markdown 列表： - 列表项目 1. 列表项目 *斜体***粗体*****加粗斜体***~~删除线~~#这3个仅适用于扩展过的typora==高亮==上标^1^下标~1~字体背景颜色：&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=orange&gt;背景色是：orange&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;字体颜色：&lt;font color=#0099ff&gt;这是#0099ff&lt;/font&gt;Markdown 插入链接：[链接文字](链接网址 \"标题\")Markdown 插入图片：![alt text](/path/to/img.jpg \"Title\")Markdown 引用：&gt; 引用内容------Markdown 换行：&lt;br&gt;Markdown 段首缩进：&amp;ensp; or &amp;#8194; 表示一个半角的空格&amp;emsp; or &amp;#8195; 表示一个全角的空格&amp;emsp;&amp;emsp; 两个全角的空格（用的比较多）&amp;nbsp; or &amp;#160; 不断行的空白格&gt;区段引用### 脚注使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Typora[^T] 编辑器进行书写。 [^1]:Markdown是一种纯文本标记语言 [^2]:HyperText Markup Language 超文本标记语言[^T]:NEW WAY TO READ &amp; WRITE MARKDOWN.### blog相关&lt;!-- more --&gt; 文章截断，在文章内容中加入可以在首页中只显示这之上的内容在文章头信息中添加descripTion字段，并填写内容，就可以在首页显示文章简述而不显示文章内容。 reference: https://blog.csdn.net/witnessai1/article/details/52551362 https://blog.csdn.net/u014061630/article/details/81359144 https://github.com/ahonn/hexo-theme-even/wiki","categories":[],"tags":[{"name":"语法","slug":"语法","permalink":"https://cedarrr.github.io/Cedarrr.github.io/tags/语法/"}]}]}