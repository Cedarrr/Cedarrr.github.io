{"meta":{"title":"Cedar's blog","subtitle":"学习笔记","description":null,"author":"Cedar","url":"https://cedarrr.github.io/Cedarrr.github.io","root":"/Cedarrr.github.io/"},"pages":[{"title":"tags","date":"2020-01-11T17:41:31.000Z","updated":"2020-01-11T17:42:14.163Z","comments":true,"path":"tags/index.html","permalink":"https://cedarrr.github.io/Cedarrr.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Python 进阶学习","slug":"python进阶学习","date":"2020-01-18T20:28:31.000Z","updated":"2020-01-21T00:12:53.191Z","comments":true,"path":"2020/01/18/python进阶学习/","link":"","permalink":"https://cedarrr.github.io/Cedarrr.github.io/2020/01/18/python进阶学习/","excerpt":"1. 基本知识1.1 解释器python解释器在加载.py文件中的代码时，会对内容进行编码（默认ascill)，所以需要在代码中加入使用utf-8解释器的代码。 1234#!/usr/bin/env python# -*- coding: utf-8 -*- print` `\"你好，世界\"","text":"1. 基本知识1.1 解释器python解释器在加载.py文件中的代码时，会对内容进行编码（默认ascill)，所以需要在代码中加入使用utf-8解释器的代码。 1234#!/usr/bin/env python# -*- coding: utf-8 -*- print` `\"你好，世界\" 1.2 用户输入注意在python2.x中尽量使用raw_input因为它会自动把用户的输入的东西存为str的格式，相当于python3当中的input。 12#raw_input仅仅只在python2.x里面有用name = raw_input(\"What is your name?\") 1.3 pycharm设置每次创建新py文件的模板view-&gt;appearance-&gt;toolbar，点击出现菜单里面的扳手符号。editor-&gt;file and code templates 1.4 用户输入这个代码不能在pycharm环境下使用，但在cmd中是可以的。 12345678#!/usr/bin/env python #_*_coding:utf-8_*_import getpassname = raw_input(\"What is your name?\")pwd=getpass.getpass(\"password:\")print(\"Hello \" + name )print(pwd) 1.5 模块初识 创建的文件名不可以与导入的库名相同，例如创建的文件叫sys那么在import sys的时候，会先在当前目录下寻找，就找到了自己创建的文件。在python2.x里会报错，但python3.x好像已经修复了这个问题。但尽量还是不要使用。 sys模块 1234567891011import sys# 打印环境变量print(sys.path)# 在pycharm中打印绝对路径# 如果是在cmd下面，打印文件名并以列表中的一项这种形式出现# python sys_mod.py 1 2 3# 结果会出现['sys_mod.py','1','2','3']# print(sys.argv[2])则会取出2这个字符print(sys.argv) os模块： 实现与系统的交互 12345# 实现与系统的交互import osos.system(\"dir\") # os.system 执行命令，不保存结果os.popen(\"dir\") # os.popen执行命令，并把结果存在一个地址，会返回地址 1.6 pyc文件lib/_pycache_文件夹中会存放pyc文件 编译型语言：C语言。就是在程序执行之前，会先同各国编译器对程序执行一个编译的过程，把程序转变为机器语言，运行时就不需要编译，速度更快。解释型语言：Python, Ruby。没有编译的过程，而是在程序运行的时候，通过解释器对程序逐行做出解释，然后直接运行。 随着Java等基于虚拟机的语言的兴起，语言不可以再被直接分为解释型和编译型这两种。以Java为例，Java首先是通过编译器编译成字节码文件，然后在运行时通过解释器给解释成机器文件，所以说Java是一种先编译后解释的语言。 在命令行中输入python hello.py的时候，其实是激活了Python的解释器告诉解释器要开始工作了。可是在“解释之前”执行的第一项工作其实和java是一样的，就是编译。 python的运行过程当python程序运行的时候，编译的结果是保存在位于内存中的PyCodeObject中，当python程序运行结束时，python解释器九江PyCodeObject写回到pyc文件中。当Python二次运行的时候，程序会先在硬盘中寻找pyc文件，如果找到，就直接写入否则就重复上面的过程。在找到pyc文件的同时，还会比较代码和pyc文件的更新时间，如果不一致还是会重复上述过程所以pyc文件其实似乎PyCodeObject的一种持久化保存方式。 1.7 基础的代码 列表的复制要用list_name.copy()而不要直接new_list=old_list。 字典的多级目录 12345678910111213data=&#123; 'new york':&#123; 'university':&#123; 'fashion':[\"left\",\"right\"] &#125; &#125;, 'uk':&#123; \"london\":[\"kings cross station\"] &#125;&#125;print(data['new york'][\"university\"][\"boston\"][0]) ## 打印结果是left 函数 匿名函数 ：就是不需要显式的指定函数 12345678910111213# 普通函数def calc(n): return n**nprint(calc(10))# 匿名函数calc=lambda n::n**nprint(calc(10))# 匿名函数一般会搭配其他的函数使用res=map(lambda x:x**2,[1,5,7,4,8])for i in res: print(i) 递归函数： 在函数内部调用自己的函数 递归必须有一个明确的结束条件 每次进入更深一层递归时，问题规模比上次递归都应有所减少 递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出） 1234567def calc(n): print(n) if int(n/2)&gt;0: # 这里必须要加int， 要不出现小数就永元不会达到这个条件 return calc(n/2) else: return 1calc(8) 递归应用于二分查找法 123456789101112131415161718192021def binary_search(dataset, find_num): print(dataset) if len(dataset) &gt; 1: mid = int(len(dataset) / 2) if dataset[mid] == find_num: # find it print(\"找到数字\", dataset[mid]) elif dataset[mid] &gt; find_num: # 找的数在mid左面 print(\"\\033[31;1m找的数在mid[%s]左面\\033[0m\" % dataset[mid]) return binary_search(dataset[0:mid], find_num) else: # 找的数在mid右面 print(\"\\033[32;1m找的数在mid[%s]右面\\033[0m\" % dataset[mid]) return binary_search(dataset[mid + 1:], find_num) else: if dataset[0] == find_num: # find it print(\"找到数字啦\", dataset[0]) else: print(\"没的分了,要找的数字[%s]不在列表里\" % find_num)data = [1, 3, 6, 7, 9, 12, 14, 16, 17, 18, 20, 21, 22, 23, 30, 32, 33, 35]binary_search(data, 66) 高阶函数：一个函数可以接收另一个函数作为参数，这种函数就称之为高阶函数。12345def add(x,y,f): return f(x)+f(y)res=add(3,-6,abs)print(res) 22.1 装饰器装饰器： 定义：本质是函数，关键语法都是用def定义的。是用来装饰其他函数，为其他函数添加附加功能。原则：1. 不能修改被装饰的函数的源代码。2. 不能修改被装饰的函数的调用方式。也就是装饰器对被修改的函数是完全透明的。 实现装饰器的知识储备：高阶函数+嵌套函数-》装饰器 函数即“变量” 高阶函数 嵌套函数 函数即变量函数就像变量一样，当创建函数的时候，就在内存中划分一个空间装函数体，函数名就相当于变量名是个门牌号。python中的内存回收机制是当没有门牌号的时候，里面的值就会被清空。匿名函数没有函数名，所以立刻会被回收。但如果匿名函数赋给给某个值，就相当于给予了门牌号。 高阶函数 把一个函数名当作实参传给另外一个函数 （在步修改被装饰函数源代码的情况下为其添加功能） 返回值中包含函数名 理解装饰器的作用方法. 123456789101112131415def bar(): print(\"in the bar\")def test1(func): print(func) return func #print(test1(bar)) # 注意这里要传bar而非bar(),因为bar是门牌号 # 而bar()是bar这个函数的运行结果，如果传bar() # 那么传给test1的就不是函数了bar=test1(bar) #这里就相当于改写了门牌号bar指向的地址bar()# output#&lt;function bar at 0x02BFE7C0&gt;#&lt;function bar at 0x02BFE7C0&gt; 嵌套函数函数的嵌套是在一个函数内容，def一个新的函数，而不只是单纯的调用某个函数。 123456def foo(): print(\"in the foo\") def bar(): # 这个函数具有局部变量的特性，不能在外部被调用。 print(\"in the bar\") bar()foo() 当没有参数的时候，装饰器的使用 12345678910111213141516171819202122import timedef timer(func): #timer(test1) func=test1 def timer2(): start_time=time.time() func() # run test1() end_time=time.time() print(\"the func run time is %s\"%(end_time-start_time)) return timer2 # 返回地址@timerdef test1(): time.sleep(3) print(\"in the test1\")# 把地址赋给这个原来的门牌号# @timer写在上面就相当于这一步# test1=timer(test1)test1() # 这里实际上是在执行timer2#output#in the test1#the func run time is 3.0004637241363525 非固定参数，装饰器。*args, **kwargs是非固定参数，此时，不管被修饰的函数有几个参数，都可以使用了 123456789101112131415import timedef timer(func): #timer(test1) func=test1 def timer2(*args,**kwargs): # *args, **kwargs是非固定参数 start_time=time.time() func(*args,**kwargs) # run test1() end_time=time.time() print(\"the func run time is %s\"%(end_time-start_time)) return timer2 # 返回地址@timerdef test1(): time.sleep(3) print(\"in the test1\")@timer # test2=timer(test2)=timer2 test2(name)=timer2(name)def test2(name): print(\"test2\",name) 进阶版，根据不同的页面，用不同的方式进行验证 123456789101112131415161718192021222324252627282930313233343536373839user,passwd=\"alex\",\"abc123\"def auth(auth_type): #print(\"auth func\",auth_type) def outer_wrapper(func): def wrapper(*args, **kwargs): #print(\"auth func args\",*args, **kwargs) username = input(\"Username:\").strip() password = input(\"Password:\").strip() if auth_type == \"local\": if user == username and passwd == password: print(\"\\033[32:1mUser has passed authentication\\033[Om\") # 以绿色的颜色打印一句登陆成功的提示语 res = func(*args, **kwargs) # 这就就相当于func在执行，但由于这个值没有传递给任何变量，所以如果原func是有返回值的 # 在这里就会丢失，所以需要在这里把res赋值 print(\"---after authentication\") return res else: exit(\"\\033[31:1mInvalid username or passwd\\033[Om\") # 以红色的颜色打印一句登陆成功的提示语 elif auth_type==\"ldap\": print(\"get ldap\") return wrapper return outer_wrapperdef index(): print(\"Welcome to index page\")@auth(auth_type=\"local\") #希望实现home页面用本地的文件验证def home(): print(\"welcome to home page\") return \"from home\"@auth(auth_type=\"ldap\") # bbs用ldap的方法验证def bbs(): print(\"welcome to bbs page\")index()print(home()) # 在这里调用hone，相当于调用wrapperbbs() 2.2 迭代器与生成器Reference: 课程网页：https://www.cnblogs.com/alex3714/articles/5465198.html","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://cedarrr.github.io/Cedarrr.github.io/tags/python/"}]},{"title":"NGS Reading","slug":"NGS-Reading","date":"2020-01-12T22:42:50.000Z","updated":"2020-01-12T22:47:30.945Z","comments":true,"path":"2020/01/12/NGS-Reading/","link":"","permalink":"https://cedarrr.github.io/Cedarrr.github.io/2020/01/12/NGS-Reading/","excerpt":"","text":"","categories":[],"tags":[{"name":"bioinformatics","slug":"bioinformatics","permalink":"https://cedarrr.github.io/Cedarrr.github.io/tags/bioinformatics/"},{"name":"reading","slug":"reading","permalink":"https://cedarrr.github.io/Cedarrr.github.io/tags/reading/"}]},{"title":"Reading list","slug":"reading-list","date":"2020-01-12T20:25:36.000Z","updated":"2020-01-12T21:11:35.884Z","comments":true,"path":"2020/01/12/reading-list/","link":"","permalink":"https://cedarrr.github.io/Cedarrr.github.io/2020/01/12/reading-list/","excerpt":"Next generation genomics: Background Reading list – Useful reference collections A collection from the journal Bioinformatics is at http://www.oxfordjournals.org/our_journals/bioinformatics/nextgenerationsequencing.html Briefings in Bioinformatics has a special issue on 2nd generation sequencing http://bib.oxfordjournals.org/content/11/5.toc Frontiers in Genetics has a special issue on quality assessment and control of high-throughput sequencing data http://journal.frontiersin.org/ResearchTopic/1683 A list of software tools for NGS is at http://seqanswers.com/forums/showthread.php?t=43","text":"Next generation genomics: Background Reading list – Useful reference collections A collection from the journal Bioinformatics is at http://www.oxfordjournals.org/our_journals/bioinformatics/nextgenerationsequencing.html Briefings in Bioinformatics has a special issue on 2nd generation sequencing http://bib.oxfordjournals.org/content/11/5.toc Frontiers in Genetics has a special issue on quality assessment and control of high-throughput sequencing data http://journal.frontiersin.org/ResearchTopic/1683 A list of software tools for NGS is at http://seqanswers.com/forums/showthread.php?t=43 NGS blogs http://ivory.idyll.org/blog/ http://omicsomics.blogspot.co.uk/ http://pathogenomics.bham.ac.uk/blog/ http://www.rna-seqblog.com/ http://core-genomics.blogspot.co.uk/ http://www.homolog.us/blogs/ https://flxlexblog.wordpress.com/","categories":[],"tags":[{"name":"bioinformatics","slug":"bioinformatics","permalink":"https://cedarrr.github.io/Cedarrr.github.io/tags/bioinformatics/"},{"name":"reading","slug":"reading","permalink":"https://cedarrr.github.io/Cedarrr.github.io/tags/reading/"}]},{"title":"生信入门阅读与理解","slug":"生信入门阅读","date":"2020-01-10T21:19:53.000Z","updated":"2020-01-15T20:09:46.492Z","comments":true,"path":"2020/01/10/生信入门阅读/","link":"","permalink":"https://cedarrr.github.io/Cedarrr.github.io/2020/01/10/生信入门阅读/","excerpt":"","text":"2019年，做生信，应该知道的十大经典套路: https://www.jianshu.com/p/84ca0b818574 多组学联合分析：http://www.yingbio.com/article-35507-108404.html 多层组学整合分析是指对来自不同组学，如基因组学，转录组学，蛋白组学和代谢组学的数据来源进行归一化处理，比较分析应用到同一个课题中。 基因组学（genomics）: 利用高通量测序获取样本中所有功能基因的序列和表达量信息。 转录组学（transcriptomics）：利用高通量测序全面快速地获取某一物种特定器官或组织在某一状态下几乎所有转录本。转录组测序可以检测到所有正在表达的的基因的变化动态。 蛋白组学（proteomics）: 利用HPLC-MSMS技术获取某一时刻样本内所有表达蛋白。蛋白组学是基因表达调控机理研究的一个重要工具。 代谢组学（Metabolomics）: 利用液质联用/气质联用技术研究在某一时刻内所有代谢物。代谢组学放大了基因和蛋白表达的微小变化。反映了机体系统的生理和病理状态。 一句话概括： 基因组学告诉可能发生什么（what possibly happen）, 转录组学告诉你正在发生什么（what probably happen）, 蛋白组学告诉你已经发生什么（what actually happen） 而代谢组学则告诉你什么确实发生了（what happened) chip-seq中的motif分析：https://www.jianshu.com/p/5868a420247c","categories":[],"tags":[{"name":"bioinformatics","slug":"bioinformatics","permalink":"https://cedarrr.github.io/Cedarrr.github.io/tags/bioinformatics/"}]},{"title":"GEO数据挖掘","slug":"01 GEO数据挖掘","date":"2020-01-10T20:40:37.000Z","updated":"2020-01-12T12:35:21.023Z","comments":true,"path":"2020/01/10/01 GEO数据挖掘/","link":"","permalink":"https://cedarrr.github.io/Cedarrr.github.io/2020/01/10/01 GEO数据挖掘/","excerpt":"","text":"01 通用文献阅读及规律02 了解GEO数据库03 数据下载的3种方式 – 得到表达矩阵由于R语言版本高于3.5，需要用新的方式安装GEOquery 123456789101112131415161718192021222324252627if (!requireNamespace(\"BiocManager\", quietly = TRUE)) install.packages(\"BiocManager\")BiocManager::install(version = \"3.10\")biocManager::install(\"GEOquery\")# 获得表达矩阵的两种方式# 1. getGEO# eset这里是个对象,里面包括表达矩阵，芯片如何设计，样本如何分组等信息。 从这个列表中提取出表达矩阵，才能进行后续的操作eset&lt;-getGEO(\"GSE42872\", destdir=\".\", #下载在当前目录 getGPL=F, # 平台信息不要 AnnotGPL=F) # 注释不要b1=exprs(eset[[1]]) # 提取表达矩阵# 2. 从网页里直接下载GEO文件，然后处理# a是一个表达矩阵a=read.table(\"GSE42872_series_matrix.txt.gz\", sep=\"\\t\",quote=\"\",fill=T, comment.char=\"!\",header=T) #不要注释信息，把第一行设置为headera[,1] # a的第一列rownames(a)=a[,1] #把a的行名设为第一列的名字a=a[,-1] #去掉原来的第一列，也就是行名的那一列## 这里b1和处理之后的a是完全相同的东西## getGEO和GEOquery就是做了方法2的代码 用GEOquery从GEO数据库下载数据：http://www.bio-info-trainee.com/bioconductor_China/software/GEOquery.html 04 ID转换技巧大全通常会出现多个探针对应同一个基因，取平均值，最大值，中位值等等，其实一个探针也可以对应多个基因，因为基因家族的问题，基因本身ID就是多种多样的，entrz ID和symbol是最重要的。 我们下载的数据通常使用的是不同的芯片探针，它们有不同的探针ID(probe id)，我们需要把它转化成entrez ID或者是symbol ID 12345678910111213141516# 观察eset列表&gt; eset[[1]]ExpressionSet (storageMode: lockedEnvironment)assayData: 33297 features, 6 samples element names: exprs protocolData: nonephenoData sampleNames: GSM1052615 GSM1052616 ... GSM1052620 (6 total) varLabels: title geo_accession ... cell type:ch1 (34 total) varMetadata: labelDescriptionfeatureData: noneexperimentData: use 'experimentData(object)' pubMedIds: 24469106 Annotation: GPL6244 这个的芯片平台是GPL6244, 需要找到对应的R包。可以直接用搜索，GPL6244 r package或是参考里生信树的文章。找到的生信平台是hugene10sttranscriptcluster。 12345678910111213biocManager::install(\"hugene10sttranscriptcluster.db\")library(hugene10sttranscriptcluster.db)ls(\"package:hugene10sttranscriptcluster.db\") #查看包里包含哪些对象ids=toTable(hugene10sttranscriptclusterSYMBOL) #用toTable函数提取数据集里面的信息&gt; head(ids) probe_id symbol1 7896759 LINC011282 7896761 SAMD113 7896779 KLHL174 7896798 PLEKHN15 7896817 ISG156 7896822 AGRN 查看基因的数量，unique：extract unique elements 是用来去除重复的symbol，只提取不同的元素。length函数统计去重之后的基因数量。 12&gt; length(unique(ids$symbol))[1] 18834 查看每个基因对应的探针。table()可以省成频数统计表，这里就是统计每个基因symbol出现的次数并将其表格化；sort()函数将symbol出现的频率从小到大排序；tail()取最后6个即出现频率最大的6个。 1234&gt; tail(sort(table(ids$symbol))) RPL41 UBTFL1 CDK11B UBE2D3 IGKC LRRFIP1 6 6 8 8 10 10 这里table()是把出现频率相同的探针继续归一，继续表格化。这里18072个基因设计了1个探针，599个基因设计了2个探针…这个表达矩阵中大部分的基因只设计了一个探针。一般基因都会设计很多探针，我们下载的表达矩阵是作者处理之后的，把许多不好的探针都过滤掉了，我们处理作者的数据要默认人家做的是对的，否则就要下载原始数据自己处理。 12345# 找到a1里面probe id里是否在ids里面 &gt; table(rownames(a1) %in% ids$probe_id) FALSE TRUE 13483 19814 #有13483个不在，19814个在dim(a1) # 探针数量，这时有33297个探针 x %in% y表示x的元素在y中吗？然后返回逻辑值。rownames(a1)即表达矩阵a1的行名，是文章数据中所用到的探针idprobe id;ids$probe_id是所有具有对应基因的所有探针。所以返回的true就是文章数据中有对应基因的探针数。 123# 过滤a1里，probe id不在R 包中的数据a1=a1[rownames(a1) %in% ids$probe_id,]dim(a1) #此时探针只剩下了19814个 这里就相当于矩阵取子集，如matrix[2,]意思就是取矩阵matrix的第2行和所有的列。同理，这里的就是取具有对应基因的所有探针，和所有的列。 用match函数把ids里的探针顺序改一下。match（）函数返回的是一个位置向量，该向量记录这第一个参数总每个远在在第2个参数中的位置。所以此时ids里的探针顺序与表达矩阵a1的探针顺序意义对应。 123456789101112131415161718# 使探针顺序与表达矩阵顺序相同ids=ids[match(rownames(a1),ids$probe_id),]&gt; head(ids) probe_id symbol1 7896759 LINC011282 7896761 SAMD113 7896779 KLHL174 7896798 PLEKHN15 7896817 ISG156 7896822 AGRN&gt; head(a1) X.GSM1052615. X.GSM1052616. X.GSM1052617. X.GSM1052618. X.GSM1052619. X.GSM1052620.7896759 8.75126 8.61650 8.81149 8.32067 8.41445 8.452087896761 8.39069 8.52617 8.43338 9.17284 9.10216 9.141207896779 8.20228 8.30886 8.18518 8.13322 8.06453 8.158847896798 8.41004 8.37679 8.27521 8.34524 8.35557 8.444097896817 7.72204 7.74572 7.78022 7.72308 7.53797 7.734017896822 9.19237 9.10929 9.03668 9.94821 9.96994 9.99839 顺序相同就可以通过ids的probe id对表达矩阵进行分类，得到探针列表。将同一个symbol所对应的多个探针分成不同的组，并对每组探针进行统计；计算每组中每行探针表达量的平均值（也就是每个探针在6个样本中表达量的均值rowMeans(x)），再取平均值最大的那个探针作为该symbol所对应的唯一探针，该组中的其他探针过滤掉，这样每个symbol就对应一个探针了，看下代码是如何操作的： 12345678910tmp=by(a1, ids$symbol, function(x) rownames(x)[which.max(rowMeans(x))])# 再把探针列表转换成probeprobes=as.character(tmp)dim(a1) #[1] 19814 6# 过滤有多个探针的基因。a1=a1[rownames(a1) %in% probes,]dim(a1) #[1] 18821 6 by()函数在这里发挥的功能就是将表达矩阵a1中的探针分组，同一个symbol所对应的多个探针分到一组，并对每组探针进行统计得到symbol所对应的唯一探针。所以tmp里放着by()函数的统计结果即每个symbol所对应的唯一探针IDprobe_id，用probes=as.character(tmp)将结果变身为纯字符型向量。 by()函数会分组计算描述性统计量，它可以一次返回若干个统计量。格式为by(data, INDICES, FUN)，其中data是一个数据框或矩阵；INDICES是一个因子或因子组成的列表，定义了分组；FUN是任意函数。by()函数就是根据因子将整个data分组成几个小的data.frame，然后进行运算处理。 这里by(a1,ids$symbol,function(x) rownames(x)[which.max(rowMeans(x))])的第2个参数ids$symbol定义了分组，将第一个参数a1表达矩阵分成了若干个小矩阵，每个小矩阵里存放着同一个symbol所对应的所有探针。但三个参数是我们自己定义的参数：计算每个小矩阵中每行探针表达量的平均值（也就是每个探针在6个样本中表达量的均值rowMeans(x)），再取平均值最大的那个探针作为该symbol, 123456&gt; head(tmp)ids$symbol A1CF A2M A2ML1 A3GALT2 A4GALT A4GNT \"7933640\" \"7960947\" \"7953775\" \"7914643\" \"8076497\" \"8090955\" &gt; head(probes)[1] \"7933640\" \"7960947\" \"7953775\" \"7914643\" \"8076497\" \"8090955\" 05 了解你的表达矩阵06 差异分析07 火山图及热图制作及美化08 KEGG-GO等数据库的注释及GSEA分析09 收尾的几点建议Reference R来完成表达芯片分析全流程：http://www.bio-info-trainee.com/2087.html 生信人的20个语言练习题： http://www.bio-info-trainee.com/3409.html 生信人的20个R语言练习题答案：http://www.bio-info-trainee.com/3415.html 生信人的linux考试： http://www.bio-info-trainee.com/2900.html 黄晶_id视频笔记：https://www.jianshu.com/p/8dd7dc1e1719 刘小泽视频笔记： https://www.jianshu.com/p/993b4022363f 用R 获取芯片探针与基因的对应关系三部曲-bioconductor（常见基因注释平台对应的R包）: http://www.bio-info-trainee.com/1399.html","categories":[],"tags":[{"name":"bioinformatics","slug":"bioinformatics","permalink":"https://cedarrr.github.io/Cedarrr.github.io/tags/bioinformatics/"},{"name":"流程","slug":"流程","permalink":"https://cedarrr.github.io/Cedarrr.github.io/tags/流程/"}]},{"title":"markdown基础语法","slug":"markdown基础语法","date":"2019-12-27T20:40:37.000Z","updated":"2020-01-12T12:25:24.030Z","comments":true,"path":"2019/12/27/markdown基础语法/","link":"","permalink":"https://cedarrr.github.io/Cedarrr.github.io/2019/12/27/markdown基础语法/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960Markdown 目录： [TOC] ### 基础语法Markdown 标题： **# 这是 H1** **## 这是 H2** **### 这是 H3** Markdown 列表： - 列表项目 1. 列表项目 *斜体***粗体*****加粗斜体***~~删除线~~#这3个仅适用于扩展过的typora==高亮==上标^1^下标~1~字体背景颜色：&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=orange&gt;背景色是：orange&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;字体颜色：&lt;font color=#0099ff&gt;这是#0099ff&lt;/font&gt;Markdown 插入链接：[链接文字](链接网址 \"标题\")Markdown 插入图片：![alt text](/path/to/img.jpg \"Title\")Markdown 引用：&gt; 引用内容------Markdown 换行：&lt;br&gt;Markdown 段首缩进：&amp;ensp; or &amp;#8194; 表示一个半角的空格&amp;emsp; or &amp;#8195; 表示一个全角的空格&amp;emsp;&amp;emsp; 两个全角的空格（用的比较多）&amp;nbsp; or &amp;#160; 不断行的空白格&gt;区段引用### 脚注使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Typora[^T] 编辑器进行书写。 [^1]:Markdown是一种纯文本标记语言 [^2]:HyperText Markup Language 超文本标记语言[^T]:NEW WAY TO READ &amp; WRITE MARKDOWN.### blog相关&lt;!-- more --&gt; 文章截断，在文章内容中加入可以在首页中只显示这之上的内容在文章头信息中添加descripTion字段，并填写内容，就可以在首页显示文章简述而不显示文章内容。 reference: https://blog.csdn.net/witnessai1/article/details/52551362 https://blog.csdn.net/u014061630/article/details/81359144 https://github.com/ahonn/hexo-theme-even/wiki","categories":[],"tags":[{"name":"语法","slug":"语法","permalink":"https://cedarrr.github.io/Cedarrr.github.io/tags/语法/"}]}]}